load http-server.maude
load metaInterpreter.maude

fmod CLI-COMMANDS is
    including LANG-SYNTAX .

    sort Command .

    --- op model from_ : Token -> Command .
    --- op assertions from_ : Token -> Command .

    op show state : -> Command .
    op trace to_ : Token -> Command .

    op always_ : Expr -> Command .
    op check last state_ : Expr -> Command .
    op dump last state : -> Command .

    op reset : -> Command .
    op reset code : -> Command .
    op reset model : -> Command .

    op quit : -> Command .

    op simulate : -> Command .
    op dump simulation : -> Command .
endfm

fmod LOOP-COMMANDS is
    including CLI-COMMANDS .
    including SERVER-SYNTAX .

    sort Input .
    subsorts ServiceList Command < Input .
endfm

mod CLI is
    protecting COMPOSITION .

    sort CliState .

    ops idle reading writing checking parsing quitting : -> CliState .
    ops loadingComposition waitingParser : String -> CliState .
    ops loadingAssertions waitingAssertionParser : String -> CliState .
    ops checkingAlways checkingLastState : ExprAST -> CliState .
    op  showingState : -> CliState .
    ops resetting resettingCode resettingModel : -> CliState .
    ops openningTraceFile printingTrace : String -> CliState .
    ops writingToTraceFile closingTraceFile : String Oid -> CliState .
    op  printingToFile : String -> CliState .
    ops simulating printingSimulationResult : -> CliState .
    op dumpingSimulationResult : -> CliState .
    op dumpingLastState : -> CliState .
    op loadingTermComposition : TermList -> CliState [ctor] .

    op cliReader : -> Oid [ctor] .
    op CliReader : -> Cid [ctor] .

    op buf :_ : String -> Attribute [ctor] .
    op state :_ : CliState -> Attribute [ctor] .
    op composition :_ : Term? -> Attribute [ctor] .
    op assertions :_ : StmtAST -> Attribute [ctor] .
    op counterexampleState :_ : Term? -> Attribute [ctor] .
    op counterexamplePath :_ : Trace? -> Attribute [ctor] .
    op simulationResult :_ : Term? -> Attribute [ctor] .
    op input :_ : TermList -> Attribute [ctor] .
    op output :_ : QidList -> Attribute [ctor] .
    op stdio :_ : Bool -> Attribute [ctor] .

    op parseCommand : String -> ResultPair? .
    op parseLang : String -> ResultPair? .


    op mergeConfigs : Term? Term -> Term .

    op commandToState : Term Type -> CliState .

    op searchCounterexample : Term StmtAST -> ResultTriple? .
    op getCounterexamplePath : Term StmtAST -> Trace? .

    op getErrorPosition : ResultPair? -> Nat .

    op tokenToString : Qid -> String .

    op printTrace : Trace? -> QidList .
    op printTrace : Trace? Term -> QidList .
    
    op printEvalResult : EvalResult ~> QidList .
    op dumpConfig : Term ~> SQidList .

    op simulate : Term -> Term .

    var CONF : Configuration .
    vars S INPUT TEXT : String .
    var IOVAL : IOValue .
    var ~RES : [EvalResult] .
    var RES : EvalResult .
    var STATE : State .
    var FUNCS : FuncStorage .
    var VARS : VarStorage .
    var STACK : Stack .
    vars CODE CODE' : StmtAST .
    vars EXPR : ExprAST .
    var ATTRS : AttributeSet .
    vars COMP COMP' T T' : Term .
    vars COMP? COMP?' : Term? .
    var N : Nat .
    vars O O' IN OUT : Oid .
    var TRACE? : Trace? .
    var TRACE : Trace .
    var COUNTER : Term? .
    var TYPE : Type .
    var R : Rule .
    var QI : Qid .
    var QIL : QidList .

    eq printTrace(failure) = 'Model '\s 'is '\s 'valid. '\s 'No '\s 'trace '\s 'to '\s 'show. '\n .
    eq printTrace(nil) = 'END '\s 'OF '\s 'TRACE '\n .
    eq printTrace({COUNTER, TYPE, R} TRACE) = printAst(COUNTER) '\n '\n '\n '\s '\s '\s '\s 'vvvvvvvvvvvvv '\n '\s '\s '\s '\s 'vvvvvvvvvvvvv '\n printTrace(TRACE) .
    eq printTrace(TRACE?, T) = printTrace(TRACE?) '\n '\n '\n printAst(T) .

    ceq tokenToString('token[T]) = string(downTerm(T, '$err)) if not parsePredefined(T, 'STRING, 'String) :: ResultPair .
    ceq tokenToString('token[T]) = downTerm(getTerm(parsePredefined(T, 'STRING, 'String)), "") if parsePredefined(T, 'STRING, 'String) :: ResultPair .

    eq getErrorPosition(noParse(N)) = N .

    var TYPE : Type .

    eq commandToState('model`from_[T], TYPE) = loadingComposition(tokenToString(T)) .
    eq commandToState('assertions`from_[T], TYPE) = loadingAssertions(tokenToString(T)) .
    eq commandToState('trace`to_[T], TYPE) = printingTrace(tokenToString(T)) .
    eq commandToState('always_[T], TYPE) = checkingAlways(processLang(T)) .
    eq commandToState('check`last`state_[T], TYPE) = checkingLastState(processLang(T)) .
    eq commandToState('show`state.Command, TYPE) = showingState .
    eq commandToState('reset.Command, TYPE) = resetting .
    eq commandToState('reset`code.Command, TYPE) = resettingCode .
    eq commandToState('reset`model.Command, TYPE) = resettingModel .
    eq commandToState('quit.Command, TYPE) = quitting .
    eq commandToState('simulate.Command, TYPE) = simulating .
    eq commandToState('dump`simulation.Command, TYPE) = dumpingSimulationResult .
    eq commandToState('dump`last`state.Command, TYPE) = dumpingLastState .
    ceq commandToState(T, TYPE) = loadingTermComposition(T) if sortLeq(upModule('LOOP-COMMANDS, false), TYPE, 'ServiceList) .

    eq mergeConfigs(COMP', COMP) = upTerm(downTerm(COMP', (none).Configuration) downTerm(COMP, (none).Configuration)) .
    eq mergeConfigs(noTerm, COMP) = COMP .

    eq parseCommand(S) = metaParse(upModule('LOOP-COMMANDS, false), tokenize(S), 'Command) .
    eq parseLang(S) = metaParse(upModule('LANG-SYNTAX, false), tokenize(S), 'TopLevel) .

    eq searchCounterexample(COMP, CODE) = metaSearch(upModule('ASSERTION-CHECK, true), COMP, 'C:Configuration, ('satisfies['C:Configuration, upTerm(CODE)] = 'false.Bool), '*, unbounded, 0) .
    eq getCounterexamplePath(COMP, CODE) = metaSearchPath(upModule('ASSERTION-CHECK, true), COMP, 'C:Configuration, ('satisfies['C:Configuration, upTerm(CODE)] = 'false.Bool), '*, unbounded, 0) .

    eq simulate(COMP) = getTerm(metaRewrite(['ASSERTION-CHECK], COMP, unbounded)) .

    eq printEvalResult(~RES) = metaPrettyPrint(['ASSERTION-CHECK], none, upTerm(~RES), mixfix format number rat) .
    eq dumpConfig(COMP) = metaPrettyPrint(['COMPOSITION], none, COMP, mixfix format number rat) .

    rl < cliReader : CliReader | state : writing, output : (QI QIL), stdio : true, ATTRS >
    =>
        < cliReader : CliReader | state : writing, output : nil, stdio : true, ATTRS >
        write(stdout, cliReader, printTokens(QI QIL) + "\n")
    .

    rl < cliReader : CliReader | state : writing, ATTRS >
        wrote(cliReader, stdout)
    =>
        < cliReader : CliReader | state : idle, ATTRS >
    .

    rl < cliReader : CliReader | buf : S, state : idle, stdio : true, ATTRS >
    =>
        < cliReader : CliReader | buf : S, state : reading, stdio : true, ATTRS >
        getLine(stdin, cliReader, "> ")
    .

    rl < cliReader : CliReader | buf : S, state : reading, input : failure, stdio : true, output : nil, ATTRS >
        gotLine(cliReader, O', INPUT)
    =>
        if (parseCommand(S + INPUT) :: ResultPair) then
            < cliReader : CliReader | buf : "", state : reading, input : parseCommand(S + INPUT), stdio : true, output : nil, ATTRS >
        else
            if getErrorPosition(parseCommand(S + INPUT)) == size(tokenize(S + INPUT)) then
                < cliReader : CliReader | buf : (S + INPUT), state : idle, input : failure, stdio : true, output : nil, ATTRS >
            else
                < cliReader : CliReader | buf : "", state : writing, input : failure, stdio : true, output : formatErrorString(S + INPUT, parseCommand(S + INPUT)), ATTRS >
            fi
        fi

    rl < cliReader : CliReader | input : {T, TYPE}, state : reading, ATTRS >
    =>
        < cliReader : CliReader | input : failure, state : commandToState(T, TYPE), ATTRS >
    .


    --- rl < cliReader : CliReader | state : loadingComposition(S), ATTRS >
    --- => < cliReader : CliReader | state : waitingParser(S), ATTRS >
    ---     scanFile(S)
    --- .

    --- rl < cliReader : CliReader | state : waitingParser(S), ATTRS >
    ---     readerError(S, TEXT)
    --- =>
    ---     < cliReader : CliReader | state : writing, ATTRS >
    ---     write(stdout, cliReader, "Error: " + TEXT + "\n")
    --- .

    --- rl < cliReader : CliReader | 
    ---     state : waitingParser(S),
    ---     composition : COMP?,
    ---     assertions : CODE,
    --- ATTRS >
    ---     scannedFile(S, TEXT)
    --- =>
    ---     if parseComposition(TEXT) :: ResultPair then
    ---         if processConfig(getTerm(parseComposition(TEXT))) :: Configuration then
    ---             if processProps(getTerm(parseComposition(TEXT))) :: StmtAST then
    ---                 < cliReader : CliReader | 
    ---                     state : writing, 
    ---                     composition : mergeConfigs(COMP?, upTerm(processConfig(getTerm(parseComposition(TEXT))))),
    ---                     assertions : (CODE ; processProps(getTerm(parseComposition(TEXT)))), 
    ---                 ATTRS >
    ---                 write(stdout, cliReader, "Composition is loaded.\n")
    ---             else
    ---                 < cliReader : CliReader | 
    ---                     state : writing, 
    ---                     composition : COMP?, 
    ---                     assertions : CODE,
    ---                 ATTRS >
    ---                 write(stdout, cliReader, getLangProcessError(processProps(getTerm(parseComposition(TEXT)))) + "\n")
    ---                 debug(getLangProcessError(processProps(getTerm(parseComposition(TEXT)))))
    ---             fi
    ---         else
    ---             < cliReader : CliReader | 
    ---                 state : writing, 
    ---                 composition : COMP?, 
    ---                 assertions : CODE,
    ---             ATTRS >
    ---             write(stdout, cliReader, getCompositionError(processConfig(getTerm(parseComposition(TEXT)))) + "\n")
    ---             debug(getCompositionError(processConfig(getTerm(parseComposition(TEXT)))))
    ---         fi
    ---     else
    ---             --- TODO assertions attr
    ---         < cliReader : CliReader | 
    ---             state : writing, 
    ---             composition : COMP?, 
    ---             assertions : CODE,
    ---         ATTRS >
    ---         write(stdout, cliReader, formatErrorString(TEXT, parseComposition(TEXT)) + "\n")
    ---     fi
    --- .

    --- rl < cliReader : CliReader | state : loadingAssertions(S), ATTRS >
    --- => < cliReader : CliReader | state : waitingAssertionParser(S), ATTRS >
    ---     scanFile(S)
    --- .

    --- rl < cliReader : CliReader | state : waitingAssertionParser(S), assertions : CODE, ATTRS >
    ---     scannedFile(S, TEXT)
    --- =>
    ---     if parseLang(TEXT) :: ResultPair then
    ---         < cliReader : CliReader | state : writing, assertions : (CODE ; processLang(getTerm(parseLang(TEXT)))), ATTRS >
    ---         write(stdout, cliReader, "Assertion code is loaded.\n")
    ---     else
    ---         < cliReader : CliReader | state : writing, assertions : CODE, ATTRS >
    ---         write(stdout, cliReader, formatErrorString(TEXT, parseLang(TEXT)) + "\n")
    ---     fi
    --- .

    --- rl < cliReader : CliReader | state : waitingAssertionParser(S), assertions : CODE, ATTRS >
    ---     readerError(S, TEXT)
    --- =>
    ---     < cliReader : CliReader | state : writing, assertions : CODE, ATTRS >
    ---     write(stdout, cliReader, "Error: " + TEXT + "\n")
    --- .

    rl < cliReader : CliReader | 
        state : waitingParser(S),
        composition : COMP?,
        assertions : CODE,
    ATTRS >
        scannedFile(S, TEXT)
    =>
        if parseComposition(TEXT) :: ResultPair then
            if processConfig(getTerm(parseComposition(TEXT))) :: Configuration then
                if processProps(getTerm(parseComposition(TEXT))) :: StmtAST then
                    < cliReader : CliReader | 
                        state : writing, 
                        composition : mergeConfigs(COMP?, upTerm(processConfig(getTerm(parseComposition(TEXT))))),
                        assertions : (CODE ; processProps(getTerm(parseComposition(TEXT)))), 
                    ATTRS >
                    write(stdout, cliReader, "Composition is loaded.\n")
                else
                    < cliReader : CliReader | 
                        state : writing, 
                        composition : COMP?, 
                        assertions : CODE,
                    ATTRS >
                    write(stdout, cliReader, getLangProcessError(processProps(getTerm(parseComposition(TEXT)))) + "\n")
                    debug(getLangProcessError(processProps(getTerm(parseComposition(TEXT)))))
                fi
            else
                < cliReader : CliReader | 
                    state : writing, 
                    composition : COMP?, 
                    assertions : CODE,
                ATTRS >
                write(stdout, cliReader, getCompositionError(processConfig(getTerm(parseComposition(TEXT)))) + "\n")
                debug(getCompositionError(processConfig(getTerm(parseComposition(TEXT)))))
            fi
        else
                --- TODO assertions attr
            < cliReader : CliReader | 
                state : writing, 
                composition : COMP?, 
                assertions : CODE,
            ATTRS >
            write(stdout, cliReader, formatErrorString(TEXT, parseComposition(TEXT)) + "\n")
        fi
    .


    rl < cliReader : CliReader | 
        state : checkingAlways(EXPR), 
        assertions : CODE, 
        composition : COMP, 
        counterexamplePath : TRACE?,
        counterexampleState : COUNTER,
    ATTRS >
    => 
        if searchCounterexample(COMP, CODE ; EXPR) :: ResultTriple then
            < cliReader : CliReader | 
                state : writing, 
                assertions : CODE, 
                composition : COMP, 
                counterexamplePath : getCounterexamplePath(COMP, CODE ; EXPR),
                counterexampleState : getTerm(searchCounterexample(COMP, CODE ; EXPR)),
            ATTRS >
            write(stdout, cliReader, "Invalid!\n")
        else
            < cliReader : CliReader | 
                state : writing, 
                assertions : CODE, 
                composition : COMP, 
                counterexamplePath : TRACE?,
                counterexampleState : COUNTER,
            ATTRS >
            write(stdout, cliReader, "Valid!\n")
        fi
    .

    rl < cliReader : CliReader | 
        state : checkingLastState(EXPR), 
        assertions : CODE, 
        composition : COMP,
        counterexamplePath : TRACE?,
        counterexampleState : COUNTER,
    ATTRS >
    => 
        < cliReader : CliReader | 
            state : writing, 
            assertions : CODE, 
            composition : COMP,
            counterexamplePath : TRACE?,
            counterexampleState : COUNTER,
        ATTRS >
        write(stdout, cliReader, printEvalResult(evalStmt(CODE ; EXPR, toState(downTerm(COUNTER, none)))) + "\n")
    .

    rl < cliReader : CliReader | 
        state : showingState,
        counterexampleState : COUNTER,
    ATTRS >
    => 
        if COUNTER =/= noTerm then
            < cliReader : CliReader | 
                state : writing, 
                counterexampleState : COUNTER,
            ATTRS >
            write(stdout, cliReader, printAst(COUNTER) + "\n")
        else
            < cliReader : CliReader | 
                state : writing,
                counterexampleState : COUNTER,
            ATTRS >
            write(stdout, cliReader, "Property is valid (or no assertions were made). No state to show.\n")
        fi
    .

    rl < cliReader : CliReader | 
        state : resetting, 
        assertions : CODE, 
        composition : COMP,
    ATTRS >
    => < cliReader : CliReader | 
            state : writing, 
            assertions : pass, 
            composition : upTerm(initConfig),
        ATTRS >
        write(stdout, cliReader, "Assertion code and composition model have been reset.\n")
    .

    rl < cliReader : CliReader | 
        state : resettingCode, 
        assertions : CODE,
    ATTRS >
    => < cliReader : CliReader | 
            state : writing, 
            assertions : pass,
        ATTRS >
        write(stdout, cliReader, "Assertion code has been reset.\n")
    .

    rl < cliReader : CliReader | 
        state : resettingModel,
        composition : COMP,
    ATTRS >
    => < cliReader : CliReader | 
            state : writing,
            composition : upTerm(initConfig),
        ATTRS >
        write(stdout, cliReader, "Composition model has been reset.\n")
    .

    rl < cliReader : CliReader | 
        state : printingTrace(S),
    ATTRS >
    =>
        < cliReader : CliReader | 
            state : openningTraceFile(S),
        ATTRS >
        openFile(fileManager, cliReader, S, "w")
    .

    rl < cliReader : CliReader | 
        state : openningTraceFile(S), 
        counterexamplePath : TRACE?,
        counterexampleState : COUNTER,
    ATTRS >
    openedFile(cliReader, fileManager, O)
    =>
        < cliReader : CliReader | 
            state : writingToTraceFile(S, O), 
            counterexamplePath : TRACE?,
            counterexampleState : COUNTER,
        ATTRS >
        debug( printTrace(TRACE?))
        write(O, cliReader, printTrace(TRACE?, COUNTER))
    .


    rl < cliReader : CliReader | 
            state : writingToTraceFile(S, O),
        ATTRS >
        wrote(cliReader, O)
    =>
        < cliReader : CliReader | 
            state : closingTraceFile(S, O),
        ATTRS >
        closeFile(O, cliReader)
    .

    rl < cliReader : CliReader | 
            state : closingTraceFile(S, O),
        ATTRS >
        closedFile(cliReader, O)
    =>
        < cliReader : CliReader | 
            state : writing,
        ATTRS >
        write(stdout, cliReader, "Trace has been printed.\n")
    .

    
    rl < cliReader : CliReader | 
        state : simulating, 
        composition : COMP,
        simulationResult : COMP?,
    ATTRS >
    => 
    < cliReader : CliReader | 
        state : printingSimulationResult, 
        composition : COMP,
        simulationResult : simulate(COMP),
    ATTRS >
    .

    rl < cliReader : CliReader | 
        state : printingSimulationResult,
        simulationResult : COMP?,
    ATTRS >
    => 
    < cliReader : CliReader | 
        state : writing, 
        simulationResult : COMP?,
    ATTRS >
    write(stdout, cliReader, printAst(COMP?) + "\n")
    .

    rl < cliReader : CliReader | 
        state : dumpingSimulationResult,
        simulationResult : COMP?,
    ATTRS >
    => 
    < cliReader : CliReader | 
        state : writing, 
        simulationResult : COMP?,
    ATTRS >
    write(stdout, cliReader, dumpConfig(COMP?) + "\n")
    .

    rl < cliReader : CliReader | 
        state : dumpingLastState,
        counterexampleState : COMP?,
    ATTRS >
    => 
    < cliReader : CliReader | 
        state : writing, 
        counterexampleState : COMP?,
    ATTRS >
    write(stdout, cliReader, dumpConfig(COMP?) + "\n")
    .

    var QIDList : QidList .
    var QID : Qid .

    op toEval : QidList -> Bool .
    eq toEval(QID QIDList) = true .
    eq toEval(nil) = false .

    op init : -> Configuration .
    eq init = < cliReader : CliReader | 
        buf : "", 
        state : idle, 
        composition : upTerm(initConfig), 
        assertions : pass,
        counterexampleState : noTerm,
        counterexamplePath : nil,
        simulationResult : noTerm
    > <> .
endm

mod CLI-LOOP is
    including LOOP-MODE .
    protecting CLI * (sort State to LangState) .

    subsort Object < State .

    op initLoop : -> System .
    op LoopCLI : -> Cid .
    op loopCli : -> Oid .

    rl [initLoop] :
     initLoop
     => [nil,
        < loopCli : LoopCLI |
            state : idle, 
            composition : upTerm(initConfig), 
            assertions : pass,
            counterexampleState : noTerm,
            counterexamplePath : nil,
            simulationResult : noTerm
        >,
         ('\n '\t '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s 'WS '\s 'Verifier '\n)] .


    var Attrs : AttributeSet .
    var QI : Qid .
    vars QIL QIL' : QidList .

    
    rl [in] :
    [QI QIL,
     < O : X@DatabaseClass |
         db : DB, input : nilTermList, output : nil, default : ME, Atts >,
     QIL']
    => if metaParse(GRAMMAR, QI QIL, '@Input@) :: ResultPair
       then [nil,
             < O : X@DatabaseClass | db : DB,
                 input : getTerm(metaParse(GRAMMAR, QI QIL, '@Input@)),
                 output : nil, default : ME, Atts >,
              QIL']
       else [nil,
             < O : X@DatabaseClass | db : DB, input : nilTermList,
                 output : ('\r 'Warning:
                           printSyntaxError(metaParse(GRAMMAR, QI QIL, '@Input@),
                             QI QIL)
                           '\n
                           '\r 'Error: '\o 'No 'parse 'for 'input. '\n),
                 default : ME, Atts >,
             QIL']
       fi .
    
endm

--- red in CLI : getCounterexamplePath(upTerm((none).Configuration), call("assert", args(bool(false)))) .
--- erew init .

mod TEST is
    protecting CLI .

    op comp : -> Configuration .
    eq comp = <> connectionManager(1) initManager(1) service("newSystem", server(code(function("create", params(id("request")), assign(
    id("agreements"), call("getPersistent", args(str("agreements")))) ; assign(id("agreement"), dict(dictItem(id("id"),
    call("len", args(id("agreements")))), dictItem(id("correspondents"), member(member(id("request"), "aggreement"),
    "correspondents")), dictItem(id("signs"), list(empty)), dictItem(id("status"), str("created")))) ; assign(id(
    "agreements"), call("append", args(id("agreements"), id("agreement")))) ; call("setPersistent", args(str("agreements"),
    id("agreements"))) ; call("respond", args(id("agreement"))))), routes(route("/create", "create"), route("/decline",
    "decline"), route("/ext/create", "extCreate"), route("/ext/decline", "extDecline"), route("/ext/retract",
    "extRetract"), route("/ext/sign", "extSign"), route("/retract", "retract"), route("/send", "send"), route("/sign",
    "sign")), persistent("agreements", list(nil)), persistent("correspondents", map(("comapnyB" |-> strVal("oldSystemB"),
    "companyA" |-> strVal("oldSystemA")))), process(connection(0, initId(0), "newSystem", httpRequest("/create", map((
    "agreement" |-> map("correspondents" |-> list(strVal("companyA") strVal("companyB"))), "user" |-> map("name" |->
    strVal("newCompanyEmployee")))))),{< executor : Executor | currentResult : evalStmt(assign(id("agreements"), call(
    "append", args(id("agreements"), id("agreement")))) ; call("setPersistent", args(str("agreements"), id("agreements")))
    ; call("respond", args(id("agreement"))), getState(evalAssign(id("agreement"),{dictVal(getDict(getValue({dictVal(
    getDict(getValue(evalExpr(dict(dictItem(id("signs"), list(empty)), dictItem(id("status"), str("created"))),[func(
    "create", params(id("request")), assign(id("agreements"), call("getPersistent", args(str("agreements")))) ; assign(id(
    "agreement"), dict(dictItem(id("id"), call("len", args(id("agreements")))), dictItem(id("correspondents"), member(
    member(id("request"), "aggreement"), "correspondents")), dictItem(id("signs"), list(empty)), dictItem(id("status"),
    str("created")))) ; assign(id("agreements"), call("append", args(id("agreements"), id("agreement")))) ; call(
    "setPersistent", args(str("agreements"), id("agreements"))) ; call("respond", args(id("agreement")))) ; func(
    "getPersistent", params(id("key")), $dispatch(id("key"), getPersistentValue) ; $lock(id("res"), getPersistentValue) ;
    return(id("res"))) ; func("request", params(id("svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id(
    "path"), id("payload")), connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res"))) ; func("respond",
    params(id("value")), $dispatch(id("value"), connectionIn)) ; func("setPersistent", params(id("key"), id("value")),
    $dispatch(list(id("key"), id("value")), setPersistentValue) ; $lock(id("res"), setPersistentValue)) | "agreements" := 9
    ; "request" := 6 | pushStack(getValue(evalExpr(member(member(id("request"), "aggreement"), "correspondents"),[func(
    "create", params(id("request")), assign(id("agreements"), call("getPersistent", args(str("agreements")))) ; assign(id(
    "agreement"), dict(dictItem(id("id"), call("len", args(id("agreements")))), dictItem(id("correspondents"), member(
    member(id("request"), "aggreement"), "correspondents")), dictItem(id("signs"), list(empty)), dictItem(id("status"),
    str("created")))) ; assign(id("agreements"), call("append", args(id("agreements"), id("agreement")))) ; call(
    "setPersistent", args(str("agreements"), id("agreements"))) ; call("respond", args(id("agreement")))) ; func(
    "getPersistent", params(id("key")), $dispatch(id("key"), getPersistentValue) ; $lock(id("res"), getPersistentValue) ;
    return(id("res"))) ; func("request", params(id("svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id(
    "path"), id("payload")), connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res"))) ; func("respond",
    params(id("value")), $dispatch(id("value"), connectionIn)) ; func("setPersistent", params(id("key"), id("value")),
    $dispatch(list(id("key"), id("value")), setPersistentValue) ; $lock(id("res"), setPersistentValue)) | "agreements" := 9
    ; "request" := 6 | stack(11, 0 |-> strVal("companyA") ; 1 |-> strVal("companyB") ; 2 |-> listVal(0, 1) ; 3 |-> dictVal(
    d("correspondents", 2)) ; 4 |-> strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |-> dictVal(d(
    "agreement", 3) ; d("user", 5)) ; 7 |-> strVal("agreements") ; 8 |-> listVal(emptyList) ; 9 |-> listVal(emptyList) ; 10
    |-> intVal(0))])), getStack(getState(evalExpr(member(member(id("request"), "aggreement"), "correspondents"),[func(
    "create", params(id("request")), assign(id("agreements"), call("getPersistent", args(str("agreements")))) ; assign(id(
    "agreement"), dict(dictItem(id("id"), call("len", args(id("agreements")))), dictItem(id("correspondents"), member(
    member(id("request"), "aggreement"), "correspondents")), dictItem(id("signs"), list(empty)), dictItem(id("status"),
    str("created")))) ; assign(id("agreements"), call("append", args(id("agreements"), id("agreement")))) ; call(
    "setPersistent", args(str("agreements"), id("agreements"))) ; call("respond", args(id("agreement")))) ; func(
    "getPersistent", params(id("key")), $dispatch(id("key"), getPersistentValue) ; $lock(id("res"), getPersistentValue) ;
    return(id("res"))) ; func("request", params(id("svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id(
    "path"), id("payload")), connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res"))) ; func("respond",
    params(id("value")), $dispatch(id("value"), connectionIn)) ; func("setPersistent", params(id("key"), id("value")),
    $dispatch(list(id("key"), id("value")), setPersistentValue) ; $lock(id("res"), setPersistentValue)) | "agreements" := 9
    ; "request" := 6 | stack(11, 0 |-> strVal("companyA") ; 1 |-> strVal("companyB") ; 2 |-> listVal(0, 1) ; 3 |-> dictVal(
    d("correspondents", 2)) ; 4 |-> strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |-> dictVal(d(
    "agreement", 3) ; d("user", 5)) ; 7 |-> strVal("agreements") ; 8 |-> listVal(emptyList) ; 9 |-> listVal(emptyList) ; 10
    |-> intVal(0))]))))]))) ; d("correspondents", lastIndex(getStack(getState(evalExpr(member(member(id("request"),
    "aggreement"), "correspondents"),[func("create", params(id("request")), assign(id("agreements"), call("getPersistent",
    args(str("agreements")))) ; assign(id("agreement"), dict(dictItem(id("id"), call("len", args(id("agreements")))),
    dictItem(id("correspondents"), member(member(id("request"), "aggreement"), "correspondents")), dictItem(id("signs"),
    list(empty)), dictItem(id("status"), str("created")))) ; assign(id("agreements"), call("append", args(id("agreements"),
    id("agreement")))) ; call("setPersistent", args(str("agreements"), id("agreements"))) ; call("respond", args(id(
    "agreement")))) ; func("getPersistent", params(id("key")), $dispatch(id("key"), getPersistentValue) ; $lock(id("res"),
    getPersistentValue) ; return(id("res"))) ; func("request", params(id("svc"), id("path"), id("payload")), $dispatch(
    list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res"))) ;
    func("respond", params(id("value")), $dispatch(id("value"), connectionIn)) ; func("setPersistent", params(id("key"),
    id("value")), $dispatch(list(id("key"), id("value")), setPersistentValue) ; $lock(id("res"), setPersistentValue)) |
    "agreements" := 9 ; "request" := 6 | stack(11, 0 |-> strVal("companyA") ; 1 |-> strVal("companyB") ; 2 |-> listVal(0,
    1) ; 3 |-> dictVal(d("correspondents", 2)) ; 4 |-> strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |->
    dictVal(d("agreement", 3) ; d("user", 5)) ; 7 |-> strVal("agreements") ; 8 |-> listVal(emptyList) ; 9 |-> listVal(
    emptyList) ; 10 |-> intVal(0))])))))), getState(evalExpr(dict(dictItem(id("signs"), list(empty)), dictItem(id(
    "status"), str("created"))),[func("create", params(id("request")), assign(id("agreements"), call("getPersistent", args(
    str("agreements")))) ; assign(id("agreement"), dict(dictItem(id("id"), call("len", args(id("agreements")))), dictItem(
    id("correspondents"), member(member(id("request"), "aggreement"), "correspondents")), dictItem(id("signs"), list(
    empty)), dictItem(id("status"), str("created")))) ; assign(id("agreements"), call("append", args(id("agreements"), id(
    "agreement")))) ; call("setPersistent", args(str("agreements"), id("agreements"))) ; call("respond", args(id(
    "agreement")))) ; func("getPersistent", params(id("key")), $dispatch(id("key"), getPersistentValue) ; $lock(id("res"),
    getPersistentValue) ; return(id("res"))) ; func("request", params(id("svc"), id("path"), id("payload")), $dispatch(
    list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res"))) ;
    func("respond", params(id("value")), $dispatch(id("value"), connectionIn)) ; func("setPersistent", params(id("key"),
    id("value")), $dispatch(list(id("key"), id("value")), setPersistentValue) ; $lock(id("res"), setPersistentValue)) |
    "agreements" := 9 ; "request" := 6 | pushStack(getValue(evalExpr(member(member(id("request"), "aggreement"),
    "correspondents"),[func("create", params(id("request")), assign(id("agreements"), call("getPersistent", args(str(
    "agreements")))) ; assign(id("agreement"), dict(dictItem(id("id"), call("len", args(id("agreements")))), dictItem(id(
    "correspondents"), member(member(id("request"), "aggreement"), "correspondents")), dictItem(id("signs"), list(empty)),
    dictItem(id("status"), str("created")))) ; assign(id("agreements"), call("append", args(id("agreements"), id(
    "agreement")))) ; call("setPersistent", args(str("agreements"), id("agreements"))) ; call("respond", args(id(
    "agreement")))) ; func("getPersistent", params(id("key")), $dispatch(id("key"), getPersistentValue) ; $lock(id("res"),
    getPersistentValue) ; return(id("res"))) ; func("request", params(id("svc"), id("path"), id("payload")), $dispatch(
    list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res"))) ;
    func("respond", params(id("value")), $dispatch(id("value"), connectionIn)) ; func("setPersistent", params(id("key"),
    id("value")), $dispatch(list(id("key"), id("value")), setPersistentValue) ; $lock(id("res"), setPersistentValue)) |
    "agreements" := 9 ; "request" := 6 | stack(11, 0 |-> strVal("companyA") ; 1 |-> strVal("companyB") ; 2 |-> listVal(0,
    1) ; 3 |-> dictVal(d("correspondents", 2)) ; 4 |-> strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |->
    dictVal(d("agreement", 3) ; d("user", 5)) ; 7 |-> strVal("agreements") ; 8 |-> listVal(emptyList) ; 9 |-> listVal(
    emptyList) ; 10 |-> intVal(0))])), getStack(getState(evalExpr(member(member(id("request"), "aggreement"),
    "correspondents"),[func("create", params(id("request")), assign(id("agreements"), call("getPersistent", args(str(
    "agreements")))) ; assign(id("agreement"), dict(dictItem(id("id"), call("len", args(id("agreements")))), dictItem(id(
    "correspondents"), member(member(id("request"), "aggreement"), "correspondents")), dictItem(id("signs"), list(empty)),
    dictItem(id("status"), str("created")))) ; assign(id("agreements"), call("append", args(id("agreements"), id(
    "agreement")))) ; call("setPersistent", args(str("agreements"), id("agreements"))) ; call("respond", args(id(
    "agreement")))) ; func("getPersistent", params(id("key")), $dispatch(id("key"), getPersistentValue) ; $lock(id("res"),
    getPersistentValue) ; return(id("res"))) ; func("request", params(id("svc"), id("path"), id("payload")), $dispatch(
    list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res"))) ;
    func("respond", params(id("value")), $dispatch(id("value"), connectionIn)) ; func("setPersistent", params(id("key"),
    id("value")), $dispatch(list(id("key"), id("value")), setPersistentValue) ; $lock(id("res"), setPersistentValue)) |
    "agreements" := 9 ; "request" := 6 | stack(11, 0 |-> strVal("companyA") ; 1 |-> strVal("companyB") ; 2 |-> listVal(0,
    1) ; 3 |-> dictVal(d("correspondents", 2)) ; 4 |-> strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |->
    dictVal(d("agreement", 3) ; d("user", 5)) ; 7 |-> strVal("agreements") ; 8 |-> listVal(emptyList) ; 9 |-> listVal(
    emptyList) ; 10 |-> intVal(0))]))))]))})) ; d("id", 10)), getState({dictVal(getDict(getValue(evalExpr(dict(dictItem(id(
    "signs"), list(empty)), dictItem(id("status"), str("created"))),[func("create", params(id("request")), assign(id(
    "agreements"), call("getPersistent", args(str("agreements")))) ; assign(id("agreement"), dict(dictItem(id("id"), call(
    "len", args(id("agreements")))), dictItem(id("correspondents"), member(member(id("request"), "aggreement"),
    "correspondents")), dictItem(id("signs"), list(empty)), dictItem(id("status"), str("created")))) ; assign(id(
    "agreements"), call("append", args(id("agreements"), id("agreement")))) ; call("setPersistent", args(str("agreements"),
    id("agreements"))) ; call("respond", args(id("agreement")))) ; func("getPersistent", params(id("key")), $dispatch(id(
    "key"), getPersistentValue) ; $lock(id("res"), getPersistentValue) ; return(id("res"))) ; func("request", params(id(
    "svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id(
    "res"), connectionOut) ; return(id("res"))) ; func("respond", params(id("value")), $dispatch(id("value"),
    connectionIn)) ; func("setPersistent", params(id("key"), id("value")), $dispatch(list(id("key"), id("value")),
    setPersistentValue) ; $lock(id("res"), setPersistentValue)) | "agreements" := 9 ; "request" := 6 | pushStack(getValue(
    evalExpr(member(member(id("request"), "aggreement"), "correspondents"),[func("create", params(id("request")), assign(
    id("agreements"), call("getPersistent", args(str("agreements")))) ; assign(id("agreement"), dict(dictItem(id("id"),
    call("len", args(id("agreements")))), dictItem(id("correspondents"), member(member(id("request"), "aggreement"),
    "correspondents")), dictItem(id("signs"), list(empty)), dictItem(id("status"), str("created")))) ; assign(id(
    "agreements"), call("append", args(id("agreements"), id("agreement")))) ; call("setPersistent", args(str("agreements"),
    id("agreements"))) ; call("respond", args(id("agreement")))) ; func("getPersistent", params(id("key")), $dispatch(id(
    "key"), getPersistentValue) ; $lock(id("res"), getPersistentValue) ; return(id("res"))) ; func("request", params(id(
    "svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id(
    "res"), connectionOut) ; return(id("res"))) ; func("respond", params(id("value")), $dispatch(id("value"),
    connectionIn)) ; func("setPersistent", params(id("key"), id("value")), $dispatch(list(id("key"), id("value")),
    setPersistentValue) ; $lock(id("res"), setPersistentValue)) | "agreements" := 9 ; "request" := 6 | stack(11, 0 |->
    strVal("companyA") ; 1 |-> strVal("companyB") ; 2 |-> listVal(0, 1) ; 3 |-> dictVal(d("correspondents", 2)) ; 4 |->
    strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |-> dictVal(d("agreement", 3) ; d("user", 5)) ; 7 |->
    strVal("agreements") ; 8 |-> listVal(emptyList) ; 9 |-> listVal(emptyList) ; 10 |-> intVal(0))])), getStack(getState(
    evalExpr(member(member(id("request"), "aggreement"), "correspondents"),[func("create", params(id("request")), assign(
    id("agreements"), call("getPersistent", args(str("agreements")))) ; assign(id("agreement"), dict(dictItem(id("id"),
    call("len", args(id("agreements")))), dictItem(id("correspondents"), member(member(id("request"), "aggreement"),
    "correspondents")), dictItem(id("signs"), list(empty)), dictItem(id("status"), str("created")))) ; assign(id(
    "agreements"), call("append", args(id("agreements"), id("agreement")))) ; call("setPersistent", args(str("agreements"),
    id("agreements"))) ; call("respond", args(id("agreement")))) ; func("getPersistent", params(id("key")), $dispatch(id(
    "key"), getPersistentValue) ; $lock(id("res"), getPersistentValue) ; return(id("res"))) ; func("request", params(id(
    "svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id(
    "res"), connectionOut) ; return(id("res"))) ; func("respond", params(id("value")), $dispatch(id("value"),
    connectionIn)) ; func("setPersistent", params(id("key"), id("value")), $dispatch(list(id("key"), id("value")),
    setPersistentValue) ; $lock(id("res"), setPersistentValue)) | "agreements" := 9 ; "request" := 6 | stack(11, 0 |->
    strVal("companyA") ; 1 |-> strVal("companyB") ; 2 |-> listVal(0, 1) ; 3 |-> dictVal(d("correspondents", 2)) ; 4 |->
    strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |-> dictVal(d("agreement", 3) ; d("user", 5)) ; 7 |->
    strVal("agreements") ; 8 |-> listVal(emptyList) ; 9 |-> listVal(emptyList) ; 10 |-> intVal(0))]))))]))) ; d(
    "correspondents", lastIndex(getStack(getState(evalExpr(member(member(id("request"), "aggreement"), "correspondents"),[
    func("create", params(id("request")), assign(id("agreements"), call("getPersistent", args(str("agreements")))) ;
    assign(id("agreement"), dict(dictItem(id("id"), call("len", args(id("agreements")))), dictItem(id("correspondents"),
    member(member(id("request"), "aggreement"), "correspondents")), dictItem(id("signs"), list(empty)), dictItem(id(
    "status"), str("created")))) ; assign(id("agreements"), call("append", args(id("agreements"), id("agreement")))) ;
    call("setPersistent", args(str("agreements"), id("agreements"))) ; call("respond", args(id("agreement")))) ; func(
    "getPersistent", params(id("key")), $dispatch(id("key"), getPersistentValue) ; $lock(id("res"), getPersistentValue) ;
    return(id("res"))) ; func("request", params(id("svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id(
    "path"), id("payload")), connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res"))) ; func("respond",
    params(id("value")), $dispatch(id("value"), connectionIn)) ; func("setPersistent", params(id("key"), id("value")),
    $dispatch(list(id("key"), id("value")), setPersistentValue) ; $lock(id("res"), setPersistentValue)) | "agreements" := 9
    ; "request" := 6 | stack(11, 0 |-> strVal("companyA") ; 1 |-> strVal("companyB") ; 2 |-> listVal(0, 1) ; 3 |-> dictVal(
    d("correspondents", 2)) ; 4 |-> strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |-> dictVal(d(
    "agreement", 3) ; d("user", 5)) ; 7 |-> strVal("agreements") ; 8 |-> listVal(emptyList) ; 9 |-> listVal(emptyList) ; 10
    |-> intVal(0))])))))), getState(evalExpr(dict(dictItem(id("signs"), list(empty)), dictItem(id("status"), str(
    "created"))),[func("create", params(id("request")), assign(id("agreements"), call("getPersistent", args(str(
    "agreements")))) ; assign(id("agreement"), dict(dictItem(id("id"), call("len", args(id("agreements")))), dictItem(id(
    "correspondents"), member(member(id("request"), "aggreement"), "correspondents")), dictItem(id("signs"), list(empty)),
    dictItem(id("status"), str("created")))) ; assign(id("agreements"), call("append", args(id("agreements"), id(
    "agreement")))) ; call("setPersistent", args(str("agreements"), id("agreements"))) ; call("respond", args(id(
    "agreement")))) ; func("getPersistent", params(id("key")), $dispatch(id("key"), getPersistentValue) ; $lock(id("res"),
    getPersistentValue) ; return(id("res"))) ; func("request", params(id("svc"), id("path"), id("payload")), $dispatch(
    list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res"))) ;
    func("respond", params(id("value")), $dispatch(id("value"), connectionIn)) ; func("setPersistent", params(id("key"),
    id("value")), $dispatch(list(id("key"), id("value")), setPersistentValue) ; $lock(id("res"), setPersistentValue)) |
    "agreements" := 9 ; "request" := 6 | pushStack(getValue(evalExpr(member(member(id("request"), "aggreement"),
    "correspondents"),[func("create", params(id("request")), assign(id("agreements"), call("getPersistent", args(str(
    "agreements")))) ; assign(id("agreement"), dict(dictItem(id("id"), call("len", args(id("agreements")))), dictItem(id(
    "correspondents"), member(member(id("request"), "aggreement"), "correspondents")), dictItem(id("signs"), list(empty)),
    dictItem(id("status"), str("created")))) ; assign(id("agreements"), call("append", args(id("agreements"), id(
    "agreement")))) ; call("setPersistent", args(str("agreements"), id("agreements"))) ; call("respond", args(id(
    "agreement")))) ; func("getPersistent", params(id("key")), $dispatch(id("key"), getPersistentValue) ; $lock(id("res"),
    getPersistentValue) ; return(id("res"))) ; func("request", params(id("svc"), id("path"), id("payload")), $dispatch(
    list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res"))) ;
    func("respond", params(id("value")), $dispatch(id("value"), connectionIn)) ; func("setPersistent", params(id("key"),
    id("value")), $dispatch(list(id("key"), id("value")), setPersistentValue) ; $lock(id("res"), setPersistentValue)) |
    "agreements" := 9 ; "request" := 6 | stack(11, 0 |-> strVal("companyA") ; 1 |-> strVal("companyB") ; 2 |-> listVal(0,
    1) ; 3 |-> dictVal(d("correspondents", 2)) ; 4 |-> strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |->
    dictVal(d("agreement", 3) ; d("user", 5)) ; 7 |-> strVal("agreements") ; 8 |-> listVal(emptyList) ; 9 |-> listVal(
    emptyList) ; 10 |-> intVal(0))])), getStack(getState(evalExpr(member(member(id("request"), "aggreement"),
    "correspondents"),[func("create", params(id("request")), assign(id("agreements"), call("getPersistent", args(str(
    "agreements")))) ; assign(id("agreement"), dict(dictItem(id("id"), call("len", args(id("agreements")))), dictItem(id(
    "correspondents"), member(member(id("request"), "aggreement"), "correspondents")), dictItem(id("signs"), list(empty)),
    dictItem(id("status"), str("created")))) ; assign(id("agreements"), call("append", args(id("agreements"), id(
    "agreement")))) ; call("setPersistent", args(str("agreements"), id("agreements"))) ; call("respond", args(id(
    "agreement")))) ; func("getPersistent", params(id("key")), $dispatch(id("key"), getPersistentValue) ; $lock(id("res"),
    getPersistentValue) ; return(id("res"))) ; func("request", params(id("svc"), id("path"), id("payload")), $dispatch(
    list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res"))) ;
    func("respond", params(id("value")), $dispatch(id("value"), connectionIn)) ; func("setPersistent", params(id("key"),
    id("value")), $dispatch(list(id("key"), id("value")), setPersistentValue) ; $lock(id("res"), setPersistentValue)) |
    "agreements" := 9 ; "request" := 6 | stack(11, 0 |-> strVal("companyA") ; 1 |-> strVal("companyB") ; 2 |-> listVal(0,
    1) ; 3 |-> dictVal(d("correspondents", 2)) ; 4 |-> strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |->
    dictVal(d("agreement", 3) ; d("user", 5)) ; 7 |-> strVal("agreements") ; 8 |-> listVal(emptyList) ; 9 |-> listVal(
    emptyList) ; 10 |-> intVal(0))]))))]))})}))), initialState :([func("create", params(id("request")), assign(id(
    "agreements"), call("getPersistent", args(str("agreements")))) ; assign(id("agreement"), dict(dictItem(id("id"), call(
    "len", args(id("agreements")))), dictItem(id("correspondents"), member(member(id("request"), "aggreement"),
    "correspondents")), dictItem(id("signs"), list(empty)), dictItem(id("status"), str("created")))) ; assign(id(
    "agreements"), call("append", args(id("agreements"), id("agreement")))) ; call("setPersistent", args(str("agreements"),
    id("agreements"))) ; call("respond", args(id("agreement")))) ; func("getPersistent", params(id("key")), $dispatch(id(
    "key"), getPersistentValue) ; $lock(id("res"), getPersistentValue) ; return(id("res"))) ; func("request", params(id(
    "svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id(
    "res"), connectionOut) ; return(id("res"))) ; func("respond", params(id("value")), $dispatch(id("value"),
    connectionIn)) ; func("setPersistent", params(id("key"), id("value")), $dispatch(list(id("key"), id("value")),
    setPersistentValue) ; $lock(id("res"), setPersistentValue)) | empty | stack(6, 0 |-> strVal("companyA") ; 1 |-> strVal(
    "companyB") ; 2 |-> listVal(0, 1) ; 3 |-> dictVal(d("correspondents", 2)) ; 4 |-> strVal("newCompanyEmployee") ; 5 |->
    dictVal(d("name", 4)))]), waiting : none >}))) service(initId(0), server(process(dummyConnection,{< executor : Executor
    | currentResult :{void, getState(evalStmt(assign(id("id"), member(id("response"), "id")) ; call("request", args(str(
    "newSystem"), str("/send"), dict(dictItem(id("user"), id("user")), dictItem(id("id"), id("id"))))), getState(
    evalAssign(id("response"), functionCallResult(params(id("svc"), id("path"), id("payload")),[func("request", params(id(
    "svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id(
    "res"), connectionOut) ; return(id("res"))) | "user" := 1 | stack(2, 0 |-> strVal("newCompanyEmployee") ; 1 |->
    dictVal(d("name", 0)))], evalStmt(return(id("res")), getState({void, locked([func("request", params(id("svc"), id(
    "path"), id("payload")), $dispatch(list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id("res"),
    connectionOut) ; return(id("res"))) | "path" := 3 ; "payload" := 10 ; "res" := 20 ; "svc" := 2 ; "user" := 1 | stack(
    21, 0 |-> strVal("newCompanyEmployee") ; 1 |-> dictVal(d("name", 0)) ; 2 |-> strVal("newSystem") ; 3 |-> strVal(
    "/create") ; 4 |-> strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |-> strVal("companyA") ; 7 |->
    strVal("companyB") ; 8 |-> listVal(6, 7) ; 9 |-> dictVal(d("correspondents", 8)) ; 10 |-> dictVal(d("agreement", 9) ;
    d("user", 5)) ; 11 |-> strVal("newSystem") ; 12 |-> strVal("/create") ; 13 |-> strVal("companyA") ; 14 |-> strVal(
    "companyB") ; 15 |-> listVal(13, 14) ; 16 |-> dictVal(d("correspondents", 15)) ; 17 |-> strVal("newCompanyEmployee") ;
    18 |-> dictVal(d("name", 17)) ; 19 |-> dictVal(d("agreement", 16) ; d("user", 18)) ; 20 |-> void)], 20,
    connectionOut)})))))))}, initialState : getState(dispatched(evalStmt(assign(id("id"), member(id("response"), "id")) ;
    call("request", args(str("newSystem"), str("/send"), dict(dictItem(id("user"), id("user")), dictItem(id("id"), id(
    "id"))))), getState(evalAssign(id("response"), functionCallResult(params(id("svc"), id("path"), id("payload")),[func(
    "request", params(id("svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id("path"), id("payload")),
    connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res"))) | "user" := 1 | stack(2, 0 |-> strVal(
    "newCompanyEmployee") ; 1 |-> dictVal(d("name", 0)))], evalStmt(return(id("res")), getState({void, locked([func(
    "request", params(id("svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id("path"), id("payload")),
    connectionOut) ; $lock(id("res"), connectionOut) ; return(id("res"))) | "path" := 3 ; "payload" := 10 ; "res" := 20 ;
    "svc" := 2 ; "user" := 1 | stack(21, 0 |-> strVal("newCompanyEmployee") ; 1 |-> dictVal(d("name", 0)) ; 2 |-> strVal(
    "newSystem") ; 3 |-> strVal("/create") ; 4 |-> strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |->
    strVal("companyA") ; 7 |-> strVal("companyB") ; 8 |-> listVal(6, 7) ; 9 |-> dictVal(d("correspondents", 8)) ; 10 |->
    dictVal(d("agreement", 9) ; d("user", 5)) ; 11 |-> strVal("newSystem") ; 12 |-> strVal("/create") ; 13 |-> strVal(
    "companyA") ; 14 |-> strVal("companyB") ; 15 |-> listVal(13, 14) ; 16 |-> dictVal(d("correspondents", 15)) ; 17 |->
    strVal("newCompanyEmployee") ; 18 |-> dictVal(d("name", 17)) ; 19 |-> dictVal(d("agreement", 16) ; d("user", 18)) ; 20
    |-> void)], 20, connectionOut)})))))), list(strVal("newSystem") strVal("/create") map(("agreement" |-> map(
    "correspondents" |-> list(strVal("companyA") strVal("companyB"))), "user" |-> map("name" |-> strVal(
    "newCompanyEmployee"))))), connectionOut)), waiting : connectionOut >}, 0))) .

    op correct : -> Configuration .
    eq correct = <> connectionManager(0) initManager(1) service("newSystem", server(code(function("create", params(id("request")), assign(
    id("agreements"), call("getPersistent", args(str("agreements")))) ; assign(id("agreement"), dict(dictItem(id("id"),
    call("len", args(id("agreements")))), dictItem(id("correspondents"), member(member(id("request"), "agreement"),
    "correspondents")), dictItem(id("signs"), list(empty)), dictItem(id("status"), str("created")))) ; assign(id(
    "agreements"), call("append", args(id("agreements"), id("agreement")))) ; call("setPersistent", args(str("agreements"),
    id("agreements"))) ; call("respond", args(id("agreement"))))), routes(route("/create", "create"), route("/decline",
    "decline"), route("/ext/create", "extCreate"), route("/ext/decline", "extDecline"), route("/ext/retract",
    "extRetract"), route("/ext/sign", "extSign"), route("/retract", "retract"), route("/send", "send"), route("/sign",
    "sign")), persistent("agreements", list(nil)), persistent("correspondents", map(("comapnyB" |-> strVal("oldSystemB"),
    "companyA" |-> strVal("oldSystemA")))))) service(initId(0), server(process(dummyConnection,{< executor : Executor |
    currentResult : dispatched({void, getState(evalStmt(assign(id("id"), member(id("response"), "id")) ; call("request",
    args(str("newSystem"), str("/send"), dict(dictItem(id("user"), id("user")), dictItem(id("id"), id("id"))))), getState(
    evalAssign(id("response"), functionCallResult(params(id("svc"), id("path"), id("payload")),[func("request", params(id(
    "svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id(
    "res"), connectionOut) ; return(id("res"))) | "user" := 1 | stack(2, 0 |-> strVal("newCompanyEmployee") ; 1 |->
    dictVal(d("name", 0)))], evalStmt(return(id("res")), getState({void, locked([func("request", params(id("svc"), id(
    "path"), id("payload")), $dispatch(list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id("res"),
    connectionOut) ; return(id("res"))) | "path" := 3 ; "payload" := 10 ; "res" := 20 ; "svc" := 2 ; "user" := 1 | stack(
    21, 0 |-> strVal("newCompanyEmployee") ; 1 |-> dictVal(d("name", 0)) ; 2 |-> strVal("newSystem") ; 3 |-> strVal(
    "/create") ; 4 |-> strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |-> strVal("companyA") ; 7 |->
    strVal("companyB") ; 8 |-> listVal(6, 7) ; 9 |-> dictVal(d("correspondents", 8)) ; 10 |-> dictVal(d("agreement", 9) ;
    d("user", 5)) ; 11 |-> strVal("newSystem") ; 12 |-> strVal("/create") ; 13 |-> strVal("companyA") ; 14 |-> strVal(
    "companyB") ; 15 |-> listVal(13, 14) ; 16 |-> dictVal(d("correspondents", 15)) ; 17 |-> strVal("newCompanyEmployee") ;
    18 |-> dictVal(d("name", 17)) ; 19 |-> dictVal(d("agreement", 16) ; d("user", 18)) ; 20 |-> void)], 20,
    connectionOut)})))))))}, list(strVal("newSystem") strVal("/create") map(("agreement" |-> map("correspondents" |-> list(
    strVal("companyA") strVal("companyB"))), "user" |-> map("name" |-> strVal("newCompanyEmployee"))))), connectionOut),
    initialState : getState(dispatched(evalStmt(assign(id("id"), member(id("response"), "id")) ; call("request", args(str(
    "newSystem"), str("/send"), dict(dictItem(id("user"), id("user")), dictItem(id("id"), id("id"))))), getState(
    evalAssign(id("response"), functionCallResult(params(id("svc"), id("path"), id("payload")),[func("request", params(id(
    "svc"), id("path"), id("payload")), $dispatch(list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id(
    "res"), connectionOut) ; return(id("res"))) | "user" := 1 | stack(2, 0 |-> strVal("newCompanyEmployee") ; 1 |->
    dictVal(d("name", 0)))], evalStmt(return(id("res")), getState({void, locked([func("request", params(id("svc"), id(
    "path"), id("payload")), $dispatch(list(id("svc"), id("path"), id("payload")), connectionOut) ; $lock(id("res"),
    connectionOut) ; return(id("res"))) | "path" := 3 ; "payload" := 10 ; "res" := 20 ; "svc" := 2 ; "user" := 1 | stack(
    21, 0 |-> strVal("newCompanyEmployee") ; 1 |-> dictVal(d("name", 0)) ; 2 |-> strVal("newSystem") ; 3 |-> strVal(
    "/create") ; 4 |-> strVal("newCompanyEmployee") ; 5 |-> dictVal(d("name", 4)) ; 6 |-> strVal("companyA") ; 7 |->
    strVal("companyB") ; 8 |-> listVal(6, 7) ; 9 |-> dictVal(d("correspondents", 8)) ; 10 |-> dictVal(d("agreement", 9) ;
    d("user", 5)) ; 11 |-> strVal("newSystem") ; 12 |-> strVal("/create") ; 13 |-> strVal("companyA") ; 14 |-> strVal(
    "companyB") ; 15 |-> listVal(13, 14) ; 16 |-> dictVal(d("correspondents", 15)) ; 17 |-> strVal("newCompanyEmployee") ;
    18 |-> dictVal(d("name", 17)) ; 19 |-> dictVal(d("agreement", 16) ; d("user", 18)) ; 20 |-> void)], 20,
    connectionOut)})))))), list(strVal("newSystem") strVal("/create") map(("agreement" |-> map("correspondents" |-> list(
    strVal("companyA") strVal("companyB"))), "user" |-> map("name" |-> strVal("newCompanyEmployee"))))), connectionOut)),
    waiting : none >}))) .

    op as : -> StmtAST .
    eq as = call("assert", args(bool(false))) .
endm

--- red getLangProcessError(function(
---     "create", params(id("request")), assign(id("agreements"), call("getPersistent", args(str("aggreements")))) ; assign(id(
---     "aggreement"), dict(dictItem(id("id"), call("len", args(id("agreements")))),dictItem(id("correspondents"), processLang(
---     'token[''request.agreements.correspondents.Qid])),dictItem(id("signs"), list(empty)))) ; assign(id("aggreements"),
---     call("append", args(id("aggreements"),id("aggreement")))) ; call("setPersistent", args(str("aggreements"),id(
---     "aggreements"))) ; call("respond", args(id("aggreement"))))) .

