load lang.maude

---(
    Definition of syntax for web services
)
fmod SERVER-SYNTAX is
    protecting STRING .
    protecting QID-LIST .

    --- tokens for a code of a web server
    sort Code .
    op codeTokens : QidList -> Code 
        [special 
            (id-hook Bubble      (1 -1) --- unlimited number of tokens
            op-hook qidListSymbol (__ : QidList QidList ~> QidList) --- separator between tokens
            op-hook qidSymbol    (<Qids> : ~> Qid) 
            id-hook Exclude     (!`}))] . --- exclude token that ends the code sequence
    
    
    --- any token
    sort Token . 
    op token : Qid -> Token 
        [special (id-hook Bubble     (1 1) 
                op-hook qidSymbol (<Qids> : ~> Qid)
                id-hook Exclude (service)) ] .


    sort Component .

    op code`{!_!`} : Code -> Component [ctor] .
    op routes {_} : Router -> Component [ctor] .

    sort Router .
    sort Route .
    subsort Route < Router .

    op _->_ : String String -> Route [ctor] .

    op noRoutes : -> Router [ctor] .
    op __ : Router Router -> Router [ctor comm assoc id: noRoutes] . 

    sort ComponentList .
    subsort Component < ComponentList .

    op empty : -> ComponentList [ctor] .
    op __ : ComponentList ComponentList -> ComponentList [ctor comm assoc id: empty] .

    sort Server .
    op {_} : ComponentList -> Server [ctor] .
    op service__; : Token Server -> Service [ctor] .

    sorts Service ServiceList .
    subsort Service < ServiceList .
    op none : -> ServiceList [ctor] .
    op __ : ServiceList ServiceList -> ServiceList [ctor assoc comm id: none] .

endfm


---(
    Inner structure and simulation of web servers
)
mod SERVER-SEMANTICS is
    extending LANG-SEMANTICS .
    protecting CONFIGURATION .
    protecting NAT .

    sort SemComponent .

    op code : StmtAST -> SemComponent [ctor] .
    op routes : SemRouter -> SemComponent [ctor] .
    op process : SemConnection StmtAST State -> SemComponent [ctor] .

    sorts SemConnId SemConnection SemRequest SemResponse .
    subsort Nat < SemConnId .

    subsort SemConnection < Object .
    op connectionManager : Nat -> Object [ctor] .
    op connection : SemConnId String String SemRequest -> SemConnection [ctor] .
    op connection : SemConnId String String SemRequest SemResponse -> SemConnection [ctor] .

    op request : String String -> SemRequest [ctor] .
    op response : String -> SemResponse [ctor] .
    op error : String -> SemResponse [ctor] .

    sort SemRouter .
    sort SemRoute .
    subsort SemRoute < SemRouter .

    op route : String String -> SemRoute [ctor] .

    op $noRoutes : -> SemRouter [ctor] .
    op _,_ : SemRouter SemRouter -> SemRouter [ctor comm assoc id: $noRoutes] . 


    sort SemComponentList .
    subsort SemComponent < SemComponentList .

    op $empty : -> SemComponentList [ctor] .
    op _,_ : SemComponentList SemComponentList -> SemComponentList [ctor comm assoc id: $empty] .

    sort SemServer .
    op server : SemComponentList -> SemServer [ctor] .

    sort SemService .
    subsort SemService < Object .
    op service : String SemServer -> SemService [ctor] .

    --- additional language constructs for send requests and responses
    op sendRequest : String SemRequest -> StmtAST [ctor] .
    op sendResponse : ExprAST -> StmtAST [ctor] .

    --- definition of predefined functions
    op serverFunctions : -> StmtAST .
    eq serverFunctions =
        --- manual definition of function respond(payload)
        function("respond", params(id("payload")), sendResponse(id("payload")) ; abort) .

    op payload : String -> StoredVar [ctor] .

    op evalServerStmt : StmtAST State -> EvalResult .

    
    var VARS VARS' : VarStorage .
    var FUNCS : FuncStorage .
    vars PARAMS PARAMS' : FuncParams .
    var ARGS : CallArgs .
    var CONN : SemConnection .
    var STACK : CallStack .
    var St : State .
    var ID : Nat .
    var S S' PATH BODY RESP : String .
    var REQ : SemRequest .
    var CODE CODE' : StmtAST .
    var EXPR : ExprAST .
    var V : Value .

    --- execution of server is the same as for the langugage
    eq evalServerStmt(CODE, [ FUNCS | VARS | STACK ]) = evalStmt(CODE, [ FUNCS | VARS | STACK ]) [owise] .
    ceq evalServerStmt(CODE ; CODE', [ FUNCS | VARS | STACK ]) 
    = evalServerStmt(CODE', getState(evalServerStmt(CODE, [ FUNCS | VARS | STACK ])))
    if CODE =/= pass and CODE' =/= pass .

    --- semantics of respond function
    eq evalStmt(sendResponse(EXPR), [ FUNCS | VARS | STACK ]) = { void, [ FUNCS | payload(getStr(getValue(evalExpr(EXPR, [ FUNCS | VARS | STACK ])))) ; VARS | STACK ] } .

endm

---(
    conversion from syntax to semantics
)
mod SERVER is
    protecting LANG * (op process : Term ~> AST to processLang) .
    protecting SERVER-SEMANTICS .
    protecting STRING .

    vars T T1 T2 : Term .
    var TL TL1 : TermList .
    var QIDS : QidList .

    op processCodeTokens : TermList ~> QidList .
    eq processCodeTokens((T, TL)) = downTerm(T, '$err) processCodeTokens(TL) .
    eq processCodeTokens(empty) = nil .

    op parseCode : QidList ~> StmtAST .
    eq parseCode(QIDS) = processLang(getTerm(metaParse(upModule('LANG-SYNTAX, false), QIDS, 'TopLevel))) .

    op processCode : TermList ~> StmtAST .
    eq processCode(TL) = parseCode(processCodeTokens(TL)) .

    op processServer : Term ~> SemServer .
    eq processServer('`{_`}[TL]) = server(processComponents(TL)) .

    op processComponents : TermList ~> SemComponentList .
    eq processComponents('empty.ComponentList) = $empty .
    eq processComponents('__[T, TL]) = processComponents(T), processComponents(TL) .

    eq processComponents('code`{!_!`}['codeTokens[TL]]) = code(processCode(TL)) .
    eq processComponents('routes`{_`}[TL]) = routes(processRoutes(TL)) .

    op processRoutes : TermList ~> SemRouter .
    eq processRoutes('noRoutes.Router) = $noRoutes .
    eq processRoutes('_->_[T, T1]) = route(
        downTerm(T, ""), 
        downTerm(T1, "")
    ) .

    op processConfig : TermList ~> Configuration .
    eq processConfig('__[T, T1]) = processConfig(T) processConfig(T1) .
    eq processConfig(empty) = none .
    eq processConfig('service__;['token[T], T1]) = service(
        string(downTerm(T, '$err)),
        processServer(T1)
    ) .

endm


---(
    interaction between servers and initialization of server side execution
)
mod SERVER-EXECUTION is
    protecting SERVER-SEMANTICS .
    protecting LANG-SEMANTICS .
    protecting CONFIGURATION .

    op makeRequest : String String String String -> Msg [msg] .

    var ID : Nat .
    var S S' BODY PATH CONTR RESP : String .
    var SERV : SemComponentList .
    var CODE : StmtAST .
    var STATE : State .
    var ROUTER : SemRouter .

    --- making request creates new connection with unique id got from connectionManager
    rl connectionManager(ID) makeRequest(S, S', PATH, BODY) 
    => 
        connectionManager(ID + 1) connection(ID, S, S', request(PATH, BODY))
    .

    --- when there is an incoming request from some connection
    rl service(S, server(SERV, code(CODE), routes(route(PATH, CONTR), ROUTER)))
        connection(ID, S', S, request(PATH, BODY))
    =>
        service(
            S, 
            server(
                SERV,
                code(CODE), 
                routes(route(PATH, CONTR), ROUTER),
                --- create a new process for the server that should run all definitions
                --- and call corresponding function for the incoming path
                process(
                    connection(ID, S', S, request(PATH, BODY)),
                    serverFunctions ; CODE ; call(CONTR, args(empty)),
                    [ empty | empty | empty ]
                )
            )
        )
    .

    --- run process
    crl 
        process(
            connection(ID, S', S, request(PATH, BODY)),
            CODE,
            STATE
        )
    =>
        process(
            connection(ID, S', S, request(PATH, BODY)),
            pass,
            getState(evalServerStmt(CODE, STATE))
        )
    if CODE =/= pass .

    var FUNCS : FuncStorage .
    var VARS : VarStorage .
    var STACK :  CallStack .

    --- if the state of the process has response payload, then pass it to the invoking connection
    rl process(
            connection(ID, S', S, request(PATH, BODY)),
            CODE,
            [ FUNCS | payload(RESP) ; VARS | STACK ]
        )
    =>
        process(
            connection(ID, S', S, request(PATH, BODY), response(RESP)),
            CODE,
            [ FUNCS | payload(RESP) ; VARS | STACK ]
        )
    .

    --- when there is a response in a process' connection, pass it to the connection one level higher
    rl service(S, server(SERV, process(
                    connection(ID, S', S, request(PATH, BODY), response(RESP)),
                    CODE,
                    STATE
                )))
    => connection(ID, S', S, request(PATH, BODY), response(RESP)) 
        service(S, server(SERV)) .
endm



---(
    commands in the meta-interpreter cli mode
)
fmod SERVER-COMMANDS is
    protecting STRING .

    sort Command .
    op load : String -> Command [ctor] .
    op quit : -> Command [ctor] .
    op print : -> Command [ctor] .
    op request : String String String String -> Command [ctor] .
endfm


---(
    CLI mode of the framework
)
mod SERVER-IO is
    protecting SERVER .
    protecting LEXICAL .
    protecting CONFIGURATION .
    protecting FILE .
    protecting MAYBE{Oid} * (op maybe to null) .
    protecting STRING .
    protecting META-LEVEL .
    protecting SERVER-COMMANDS .
    protecting SERVER-EXECUTION .
    including STD-STREAM . 

    vars S TEXT FILE : String .

    --- create semantics for web services from a source code
    op generate : String -> SemServer .
    eq generate(S) = processServer(getTerm(metaParse(upModule('SERVER-SYNTAX, false), tokenize(S), 'Server))) .

    --- create full environment
    op toConfig : String -> Configuration .
    eq toConfig(S) = processConfig(getTerm(metaParse(upModule('SERVER-SYNTAX, false), tokenize(S), 'ServiceList))) .

    op composition : -> Oid [ctor] .
    op Composition : -> Cid [ctor] .
    op action :_ : Command -> Attribute [ctor] .
    op state :_ : Configuration -> Attribute [ctor] .
    op in :_ : Maybe{Oid} -> Attribute [ctor] .
    op inStr :_ : String -> Attribute [ctor] .

    op idle : -> Command [ctor] .
    op loadMsg : String -> Msg [ctor] .
    op debug : Universal -> Msg [poly(1) ctor] .
    

    var Attrs : AttributeSet .
    vars FHIn : Oid .
    var CONF : Configuration .
    var O O' : Oid .
    var COMM : Command .
    vars SERV SERV1 PATH BODY : String .
    var N : Nat .

    op makeMsg : Command -> Configuration .
    
    eq makeMsg(load(FILE)) = loadMsg(FILE) .
    eq makeMsg(quit) = write(stdout, composition, "Goodbye!\n") .
    eq makeMsg(print) = none .
    eq makeMsg(request(SERV, SERV1, PATH, BODY)) = none .
    eq makeMsg(COMM) = write(stdout, composition, "Invalid command\n") [owise] .

    op init : -> Configuration .
    eq init =
        <>
        < composition : Composition | in : null, state : connectionManager(0), inStr : "", action : idle >
        write(stdout, composition, "WS Composition Verification\n") 
    .

    rl < composition : Composition | action : idle, Attrs >
        wrote(composition, O')
    =>
        < composition : Composition | action : idle, Attrs >
        getLine(stdin, composition, "> ")
    .

    rl < composition : Composition | action : idle, Attrs >
        gotLine(composition, O', S)
    =>
        < composition : Composition | action : downTerm( 
                     getTerm( 
                      metaParse(upModule('SERVER-COMMANDS, false), tokenize(S), 'Command)), 
                     idle), Attrs >
        makeMsg(downTerm( 
                     getTerm( 
                      metaParse(upModule('SERVER-COMMANDS, false), tokenize(S), 'Command)), 
                     idle))
    .

    rl < composition : Composition | in : null, action : load(FILE), Attrs >
        loadMsg(FILE)
    =>
        < composition : Composition | in : null, action : load(FILE), Attrs >
        openFile(fileManager, composition, FILE, "r")
    .
    
    rl < composition : Composition | in : null, action : load(FILE), Attrs >
        openedFile(composition, fileManager, FHIn)
    =>
        < composition : Composition | in : FHIn, action : load(FILE), Attrs >
        getLine(FHIn, composition)
    .

    rl < composition : Composition | in : FHIn, inStr : S, state : CONF, action : load(FILE), Attrs >
        gotLine(composition, FHIn, TEXT)
    =>
        if TEXT == "" then 
            closeFile(FHIn, composition)
            if toConfig(S) :: Configuration then
                write(stdout, composition, "loaded specification from " + FILE + "\n")
                < composition : Composition | in : null, inStr : "", state : (CONF toConfig(S)), action : idle, Attrs >
            else
                write(stdout, composition, "bad syntax in " + FILE + "\n")
                < composition : Composition | in : null, inStr : "", state : CONF, action : idle, Attrs >
            fi
        else
            < composition : Composition | in : FHIn, inStr : (S + TEXT), state : CONF, action : load(FILE), Attrs >
            getLine(FHIn, composition)
        fi .

    rl < composition : Composition | action : print, state : CONF, Attrs >
    =>
        < composition : Composition | action : idle, state : CONF, Attrs >
        write(stdout, composition, printTokens(metaPrettyPrint(upModule('SERVER-SEMANTICS, true), none, 
                upTerm(CONF), 
                mixfix)) + "\n")
    .

    rl < composition : Composition | action : request(SERV, SERV1, PATH, BODY), state : CONF, Attrs >
    =>
        < composition : Composition | action : print, state : downTerm(getTerm(metaRewrite(upModule('SERVER-EXECUTION, true), upTerm(CONF makeRequest(SERV, SERV1, PATH, BODY)), unbounded)), none), Attrs >
    .
endm
