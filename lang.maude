
---(
    This module defines parsing of the language input
)
fmod LANG-SYNTAX is
    protecting QID-LIST .

    --- special definition for any token read by maude tokenizer
    sort Token . 
    op token : Qid -> Token 
        [special (id-hook Bubble     (1 1) --- min/max number of any token for the term (only 1 token allowed)
                op-hook qidSymbol (<Qids> : ~> Qid)
                id-hook Exclude (pass, function, `(, `), ;, =, return )) ] . --- disallow special words

    sort Expr .
    subsort Token < Expr .
    sort Stmt .
    sort Decl .
    sort TopLevel .
    subsort Stmt Decl < TopLevel .
    sorts Arg ArgList .
    subsort Expr < Arg < ArgList .
    sort TokenList .
    subsort Token < TokenList .
    subsort TokenList < ArgList .

    --- Parsing
    op _; : Expr -> Stmt .
    op _+_ : Expr Expr -> Expr [gather (e E)] .
    op _-_ : Expr Expr -> Expr [gather (e E)] .
    op _*_ : Expr Expr -> Expr [gather (e E)] .
    op _/_ : Expr Expr -> Expr [gather (e E)] .

    op _==_ : Expr Expr -> Expr [gather (e E)] .
    op _!=_ : Expr Expr -> Expr [gather (e E)] .
    op _>_ : Expr Expr -> Expr [gather (e E)] .
    op _<_ : Expr Expr -> Expr [gather (e E)] .
    op _>=_ : Expr Expr -> Expr [gather (e E)] .
    op _<=_ : Expr Expr -> Expr [gather (e E)] .
    op _&&_ : Expr Expr -> Expr [gather (e E)] .
    op _||_ : Expr Expr -> Expr [gather (e E)] .

    op if_{_} : Expr Stmt -> Stmt .
    op if_{_} else {_} : Expr Stmt Stmt -> Stmt .
    op while_{_} : Expr Stmt -> Stmt .

    op `(_`) : Expr -> Expr .
    op _=_; : Expr Expr -> Stmt .
    op pass ; : -> Stmt .
    op __ : Stmt Stmt -> Stmt [assoc prec 50] .
    op function_`(`) {_} : Token Stmt -> Stmt .
    op function_`(_`) {_} : Token TokenList Stmt -> Stmt .
    op _`(`) : Token -> Expr .
    op _`(_`) : Token ArgList -> Expr [prec 15] .
    op _,_ : ArgList ArgList -> ArgList [assoc] .
    op return_; : Expr -> Stmt .
endfm


---(
    Definitions of the inner structure of language execution
)
fmod LANG-AST is

    protecting INT .
    protecting STRING .
    protecting FLOAT .

    sort AST .

    sort ExprAST .
    sort StmtAST .
    sort Ident .
    subsort ExprAST < StmtAST < AST .
    subsort Ident < ExprAST .
    sort DeclAST .
    subsort DeclAST < StmtAST .

    sorts ArgAST ArgListAST ParamAST ParamListAST .
    subsort ExprAST < ArgAST < ArgListAST .
    subsort Ident < ParamListAST .
    subsort ParamListAST < ArgListAST .

    op empty : -> ParamListAST [ctor] . --- list of parameters in function definition
    op _,_ : ArgListAST ArgListAST -> ArgListAST [ctor assoc id: empty] . --- list of passed arguments in function call
    op _,_ : ParamListAST ParamListAST -> ParamListAST [ditto] .
    op _,_ : ArgListAST ParamListAST -> ArgListAST [ditto] .
    op _,_ : ParamListAST ArgListAST -> ArgListAST [ditto] .

    op id : String -> Ident [ctor] . --- identifier
    op str : String -> ExprAST [ctor] . --- string literal
    op int : Int -> ExprAST [ctor] . --- integer literal
    op float : Float -> ExprAST [ctor] . --- integer literal
    ops $add $sub $mult $div $gt $ge $lt $le $and $or $eq $ne : ExprAST ExprAST -> ExprAST [ctor] . --- binary operations
    op assign : ExprAST ExprAST -> StmtAST [ctor] . --- =
    op pass : -> StmtAST [ctor] . --- nothing
    op return : ExprAST -> StmtAST [ctor] . --- return from function
    op $ifelse : ExprAST StmtAST StmtAST -> StmtAST [ctor] .
    op $while : ExprAST StmtAST -> StmtAST [ctor] .

    op abort : -> StmtAST [ctor] . --- end execution

    sort IO .
    op $lock : ExprAST IO -> StmtAST [ctor] .
    op $dispatch : ExprAST IO -> StmtAST [ctor] .

    op _;_ : StmtAST StmtAST -> StmtAST [ctor assoc id: pass] .

    op function : String FuncParams StmtAST -> DeclAST [ctor] . --- function definition
    op function : String FuncParams -> DeclAST [ctor] .
    op call : String CallArgs -> ExprAST [ctor] . --- function call

    sort CallArgs .
    op args : ArgListAST -> CallArgs [ctor] .

    sort FuncParams .
    op params : ParamListAST -> FuncParams [ctor] .

    sort Value .
    op void : -> Value [ctor] .
    op delete : -> Value [ctor] .
    op strVal : String -> Value [ctor] .
    op intVal : Int -> Value [ctor] .
    op floatVal : Float -> Value [ctor] .
    op boolVal : Bool -> Value [ctor] .
    op refVal : Nat -> Value [ctor] .
    op listVal : Nat -> Value [ctor] .
endfm

view Value from DEFAULT to LANG-AST is
    sort Elt to Value .
    op 0 to delete .
endv

---(
    Definition of how the language is interpreted
)
fmod LANG-SEMANTICS is
    protecting LANG-AST .
    protecting CONVERSION .
    protecting ARRAY{Nat, Value} .
    
    sort State .

    --- inner state of the execution. Stores defined functions and variables. CallStack is not used anymore
    op [_|_|_] : FuncStorage VarStorage Stack -> State [ctor prec 50 gather (e e &)] .

    sort FuncStorage .
    sort Func .
    subsort Func < FuncStorage .

    op empty : -> FuncStorage [ctor] .
    op _;_ : FuncStorage FuncStorage -> FuncStorage [ctor comm assoc id: empty prec 45] . 

    op func(_,_,_) : String FuncParams StmtAST -> Func [ctor format (b b b b b b b b o)] .

    sort StoredVar .
    sort VarStorage .
    subsort StoredVar < VarStorage .

    op empty : -> VarStorage [ctor] .
    op _;_ : VarStorage VarStorage -> VarStorage [ctor comm assoc id: empty prec 45] .
    
    --- storing index of a variable on the stack
    op _:=_ : String Nat -> StoredVar [ctor] .
    --- storing returned value from a function
    op returnVal : Value -> StoredVar [ctor] .

    sort Stack .
    op stack : Nat Array{Nat, Value} -> Stack [ctor] .

    --- result from evaluation of a code (left contains value of evaluated expression, right is resulting state)
    sort EvalResult .
    op {_,_} : Value State -> EvalResult [ctor] .

    var V V' : Value .
    var St St' : State .

    --- instead of making it return exact sort, we return the kind of the sort.
    --- this prevents derivations of the operators until they return an actual Value/State
    op getValue : EvalResult -> [Value] .
    eq getValue({V, St}) = V .

    op getState : EvalResult -> [State] .
    eq getState({V, St}) = St .

    var I : Int .

    op isInt : Value -> Bool .
    eq isInt(intVal(I)) = true .
    eq isInt(V) = false [owise] .

    op isInt : EvalResult -> Bool .
    eq isInt({V, St}) = isInt(V) .

    op getInt : Value -> Int .
    eq getInt(intVal(I)) = I .

    var STR : String .
    
    op isStr : Value -> Bool .
    eq isStr(strVal(STR)) = true .
    eq isStr(V) = false [owise] .

    op isStr : EvalResult -> Bool .
    eq isStr({V, St}) = isStr(V) .

    op getStr : Value -> String .
    eq getStr(strVal(STR)) = STR .

    var B : Bool .

    op getBool : Value -> Bool .
    eq getBool(boolVal(B)) = B .

    var F : Float .

    op isFloat : Value -> Bool .
    eq isFloat(floatVal(F)) = true .
    eq isFloat(V) = false [owise] .

    op isFloat : EvalResult -> Bool .
    eq isFloat({V, St}) = isFloat(V) .

    op getFloat : Value -> Float .
    eq getFloat(floatVal(F)) = F .
    eq getFloat(intVal(I)) = toFloat(I) .

    op isNum : EvalResult -> Bool .
    eq isNum({V, St}) = isFloat(V) or isInt(V) .

    op toFloat : Float -> Float .
    op toFloat : Int -> Float .
    eq toFloat(F) = F .
    eq toFloat(I) = float(I) .

    var N : Nat .

    op isRef : Value -> Bool .
    eq isRef(refVal(N)) = true .
    eq isRef(V) = false [owise] .

    op isRef : EvalResult -> Bool .
    eq isRef({V, St}) = isRef(V) .

    op getRef : Value -> Nat .
    eq getRef(refVal(N)) = N .

    vars E E1 : ExprAST .
    vars S S1 : StmtAST .

    --- evaluation of an expression with resulting value
    op evalExpr : ExprAST State -> [EvalResult] .
    --- evaluation of reference value
    op evalRefExpr : ExprAST State -> [EvalResult] .
    --- evaluation of a statement without result
    op evalStmt : StmtAST State -> [EvalResult] .

    sort CallStack .
    subsort State < CallStack .
    op empty : -> CallStack [ctor] .
    op aborted : VarStorage ~> State [ctor] .
    op error : String ~> State [ctor] .
    op locked : State Nat IO ~> State [ctor] .
    op dispatched : EvalResult Value IO ~> EvalResult [ctor] .

    --- if statement is just an expression evaluate it
    eq evalStmt(E, St) = evalExpr(E, St) .

    --- evaluate addition as integer addition if both values are integers
    ceq evalExpr($add(E, E1), St) = { intVal(getInt(getValue(evalExpr(E, St))) + getInt(getValue(evalExpr(E1, St)))), St }
        if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) .
    --- ceq evalExpr($sub(E, E1), St) = { intVal(getInt(getValue(evalExpr(E, St))) - getInt(getValue(evalExpr(E1, St)))), St }
    ---     if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) .
    ceq evalExpr($mult(E, E1), St) = { intVal(getInt(getValue(evalExpr(E, St))) * getInt(getValue(evalExpr(E1, St)))), St }
        if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) .
    ceq evalExpr($div(E, E1), St) = { floatVal(toFloat(getInt(getValue(evalExpr(E, St)))) / toFloat(getInt(getValue(evalExpr(E1, St))))), St }
        if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) .

        
    ceq evalExpr($add(E, E1), St) = { floatVal(toFloat(getFloat(getValue(evalExpr(E, St)))) + toFloat(getFloat(getValue(evalExpr(E1, St))))), St }
        if (isFloat(evalExpr(E, St)) and isNum(evalExpr(E1, St))) or (isFloat(evalExpr(E1, St)) and isNum(evalExpr(E, St))) .
    --- ceq evalExpr($sub(E, E1), St) = { floatVal(toFloat(getFloat(getValue(evalExpr(E, St)))) - toFloat(getFloat(getValue(evalExpr(E1, St))))), St }
    ---     if (isFloat(evalExpr(E, St)) and isNum(evalExpr(E1, St))) or (isFloat(evalExpr(E1, St)) and isNum(evalExpr(E, St))) .
    ceq evalExpr($mult(E, E1), St) = { floatVal(toFloat(getFloat(getValue(evalExpr(E, St)))) * toFloat(getFloat(getValue(evalExpr(E1, St))))), St }
        if (isFloat(evalExpr(E, St)) and isNum(evalExpr(E1, St))) or (isFloat(evalExpr(E1, St)) and isNum(evalExpr(E, St))) .
    ceq evalExpr($div(E, E1), St) = { floatVal(toFloat(getFloat(getValue(evalExpr(E, St)))) / toFloat(getFloat(getValue(evalExpr(E1, St))))), St }
        if (isFloat(evalExpr(E, St)) and isNum(evalExpr(E1, St))) or (isFloat(evalExpr(E1, St)) and isNum(evalExpr(E, St))) .

    ceq evalExpr($eq(E, E1), St) = { boolVal(true), St }
        if getValue(evalExpr(E, St)) == getValue(evalExpr(E1, St)) .
    eq evalExpr($eq(E, E1), St) = { boolVal(false), St } [owise] .
    
    ceq evalExpr($ne(E, E1), St) = { boolVal(true), St }
        if getValue(evalExpr(E, St)) =/= getValue(evalExpr(E1, St)) .
    eq evalExpr($ne(E, E1), St) = { boolVal(false), St } [owise] .
    
    ceq evalExpr($lt(E, E1), St) = { boolVal(true), St }
        if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) and getInt(getValue(evalExpr(E, St))) < getInt(getValue(evalExpr(E1, St))) .
    ceq evalExpr($lt(E, E1), St) = { boolVal(false), St } if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) [owise] .
    
    ceq evalExpr($gt(E, E1), St) = { boolVal(true), St }
        if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) and getInt(getValue(evalExpr(E, St))) > getInt(getValue(evalExpr(E1, St))) .
    ceq evalExpr($gt(E, E1), St) = { boolVal(false), St } if isInt(evalExpr(E, St)) and isInt(evalExpr(E1, St)) [owise] .

    var VARS VARS' : VarStorage .
    var FUNCS : FuncStorage .
    vars PARAMS PARAMS' : FuncParams .
    var ARGS : CallArgs .
    var STACK : Stack .

    op validState : State -> Bool .
    eq validState([ FUNCS | VARS | STACK ]) = valid(VARS) .
    --- eq validState(locked(St, N)) = validState(St) .

    op valid : VarStorage -> Bool .
    ceq valid(VARS ; VARS') = valid(VARS) and valid(VARS') if VARS =/= empty and VARS' =/= empty .
    eq valid(STR := N) = true .
    eq valid(returnVal(V)) = true .
    eq valid(empty) = true .
    
    op getVars : State -> VarStorage .
    eq getVars([ FUNCS | VARS | STACK ]) = VARS .

    --- retrieve value of the variable
    eq evalExpr(id(STR), St) = { getStackValue(getRef(getValue(evalRefExpr(id(STR), St))), getState(evalRefExpr(id(STR), St))), St } .
    --- integer literal
    eq evalExpr(int(I), St) = { intVal(I), St } .
    --- string literal
    eq evalExpr(str(STR), St) = { strVal(STR), St } .

    eq evalExpr(float(F), St) = { floatVal(F), St } .

    --- evaluate second statement based on the resulting state of previous statement
    ceq evalStmt(S ; S1, St) = evalStmt(S1, getState(evalStmt(S, St))) if S =/= pass and S1 =/= pass and validState(St) .
    eq evalStmt(pass, St) = { void, St }  .

    --- variable assignment
    ceq evalStmt(assign(E, E1), St) = evalAssign(E, evalExpr(E1, St)) if validState(St) .

    op evalAssign : ExprAST EvalResult ~> EvalResult .
    eq evalAssign(E, { V, St }) = { void, assignValue(getRef(getValue(evalRefExpr(E, St))), V, getState(evalRefExpr(E, St))) } .

    --- function return
    eq evalStmt(return(E), St) = evalReturn(evalExpr(E, St)) .

    op evalReturn : EvalResult ~> EvalResult .
    eq evalReturn({V, [ FUNCS | returnVal(V') ; VARS | STACK ]}) = { void, [ FUNCS | returnVal(V) ; VARS | STACK ] } .
    eq evalReturn({V, [ FUNCS | VARS | STACK ]}) = { void, [ FUNCS | returnVal(V) ; VARS | STACK ] } [owise] .

    --- function definition
    ceq evalStmt(function(STR, PARAMS, S), [ func(STR, PARAMS', S1) ; FUNCS | VARS | STACK ]) = { void, [ func(STR, PARAMS, S) ; FUNCS | VARS | STACK ] } if validState([ func(STR, PARAMS', S1) ; FUNCS | VARS | STACK ]) .
    ceq evalStmt(function(STR, PARAMS, S), [ FUNCS | VARS | STACK ]) = { void, [ func(STR, PARAMS, S) ; FUNCS | VARS | STACK ] } if validState([ FUNCS | VARS | STACK ]) [owise] .

    --- function call

    eq evalExpr(call(STR, ARGS), [ func(STR, PARAMS, S) ; FUNCS | VARS | STACK ]) = 
        functionCallResult(PARAMS, [ func(STR, PARAMS, S) ; FUNCS | VARS | STACK ], evalStmt(
            S,
            [ 
                --- evaluate body of the function based on the current state and argument substitutions
                func(STR, PARAMS, S) ; FUNCS 
                | getVars(addArgs(ARGS, PARAMS, [ func(STR, PARAMS, S) ; FUNCS | VARS | STACK ]))
                | getStack(addArgs(ARGS, PARAMS, [ func(STR, PARAMS, S) ; FUNCS | VARS | STACK ]))
            ]
        )) .

    var RES : EvalResult .

    op functionCallResult : FuncParams State EvalResult -> [EvalResult] .
    ceq functionCallResult(PARAMS, [ FUNCS | VARS | STACK ], {V, St}) ={ 
        getReturnValue({V, St}),
        [ FUNCS
        --- rollback variables (no globals)
        | VARS
        | getStack(St)
        ]
    } if validState(St) .

    ceq evalStmt($while(E, S), St) = (if getBool(getValue(evalExpr(E, St))) then 
        evalStmt($while(E, S), getState(evalStmt(S, St)))
    else
        evalStmt(pass, St)
    fi) if validState(St) .

    eq evalStmt($ifelse(E, S, S1), St) = (if getBool(getValue(evalExpr(E, St))) then 
        evalStmt(S, St) 
    else 
        evalStmt(S1, St)
    fi)
    .

    --- program abortion
    eq evalExpr(S, aborted(VARS)) = { void, aborted(VARS) } .
    eq evalStmt(S, aborted(VARS)) = { void, aborted(VARS) } .
    eq evalStmt(abort, St) = { void, aborted(getVars(St)) } .

    var Io : IO .
    eq evalStmt($lock(E, Io), St) = { void, locked(getState(evalRefExpr(E, St)), getRef(getValue(evalRefExpr(E, St))), Io) } .

    eq evalStmt($dispatch(E, Io), St) = evalDispatch(evalExpr(E, St), Io).

    op evalDispatch : EvalResult IO ~> EvalResult .
    eq evalDispatch({V, St}, Io) = dispatched({ void, St }, V, Io) .

    op getReturnValue : EvalResult -> [Value] .
    eq getReturnValue({ void, [ FUNCS | returnVal(V) ; VARS | STACK ] }) = V .
    eq getReturnValue({ void, aborted(VARS) }) = void .
    eq getReturnValue({ V, St }) = void [owise] .


    var ARG : ArgAST .
    var ARGLIST : ArgListAST .
    var PARAM : ParamAST .
    var PARAMLIST : ParamListAST .
    var N' : Nat .

    eq evalRefExpr(id(STR), [ FUNCS | STR := N ; VARS | STACK ]) = { refVal(N), [ FUNCS | STR := N ; VARS | STACK ] } .
    eq evalRefExpr(id(STR), [ FUNCS | VARS | STACK ]) = { refVal(lastIndex(STACK)), [ FUNCS | STR := lastIndex(STACK) ; VARS | pushStack(void, STACK) ] } [owise] .


    --- assigning variables for function call
    op assignVar : String ExprAST State -> State .
    eq assignVar(STR, E, [ FUNCS | STR := N ; VARS | STACK ]) = 
        [ FUNCS 
        | STR := lastIndex(STACK) ; VARS 
        | pushStack(getValue(evalExpr(E, [ FUNCS | STR := N ; VARS | STACK ])), STACK)
        ] .
    eq assignVar(STR, E, [ FUNCS | VARS | STACK ]) = 
        [ FUNCS 
        | STR := lastIndex(STACK) ; VARS 
        | pushStack(getValue(evalExpr(E, [ FUNCS | VARS | STACK ])), STACK)
        ] [owise] .

    op addArgs : CallArgs FuncParams State -> State .
    eq addArgs(args(E, ARGLIST), params(id(STR), PARAMLIST), St) = addArgs(args(ARGLIST), params(PARAMLIST), assignVar(STR, E, St)) .
    eq addArgs(args(empty), params(empty), St) = St .

    var ARR : Array{Nat, Value} .

    op assignValue : Nat Value State -> State .
    ceq assignValue(N, V, [ FUNCS | VARS | stack(N', ARR) ]) = 
        [ FUNCS | VARS | stack(N', insert(N, V, ARR)) ]
    if N < N' .

    op pushStack : Value Stack -> Stack .
    eq pushStack(V, stack(N', ARR)) = stack(N' + 1, insert(N', V, ARR)) .

    op getStackValue : Nat State -> Value .
    eq getStackValue(N, [ FUNCS | VARS | stack(N', ARR) ]) = ARR [ N ] .

    op lastIndex : Stack -> Nat .
    eq lastIndex(stack(N, ARR)) = N .

    op getStack : State -> Stack .
    eq getStack([ FUNCS | VARS | STACK ]) = STACK .

    var ~RES : [EvalResult] .
    var ~St : [State] .
    var ~V : [Value] .
    op unlock : EvalResult Value -> [EvalResult] .
    op unlockState : State Value -> [State] .
    
    eq unlock(functionCallResult(PARAMS, St, ~RES), V) = functionCallResult(PARAMS, St, unlock(~RES, V)) .
    eq unlock(evalStmt(S, ~St), V) = evalStmt(S, unlockState(~St, V)) .
    eq unlock(evalExpr(E, ~St), V) = evalExpr(E, unlockState(~St, V)) .
    eq unlock(evalAssign(E, ~RES), V) = evalAssign(E, unlock(~RES, V)) .
    eq unlock(evalReturn(~RES), V) = evalReturn(unlock(~RES, V)) .
    eq unlock({V', ~St}, V) = {V', unlockState(~St, V)} .

    eq unlockState(locked(St, N, Io), V) = assignValue(N, V, St) .
    eq unlockState(getState(~RES), V) = getState(unlock(~RES, V)) .


    eq functionCallResult(PARAMS, St', dispatched(~RES, V, Io)) = dispatched(functionCallResult(PARAMS, St', ~RES), V, Io) .
    eq evalStmt(S, getState(dispatched(~RES, V, Io))) = dispatched(evalStmt(S, getState(~RES)), V, Io) .
endfm


---(
    Utility module for checking if a token is a valid identifier
)
fmod IDENTIFIER is 
    protecting STRING .
    protecting BOOL .

    var S : String .

    op valid : String -> Bool .
    eq valid(S) = startsWithLetter(S) and onlyValidChars(S) .

    op startsWithLetter : String -> Bool .
    eq startsWithLetter(S) = (ascii(substr(S, 0, 1)) >= ascii("A") and ascii(substr(S, 0, 1)) <= ascii("Z"))
                            or (ascii(substr(S, 0, 1)) >= ascii("a") and ascii(substr(S, 0, 1)) <= ascii("z"))
     .

    op onlyValidChars : String -> Bool .
    ceq onlyValidChars(S) = validChar(substr(S, 0, 1)) and onlyValidChars(substr(S, 1, length(S))) 
        if S =/= "" .
    eq onlyValidChars("") = true .

    op validChar : Char -> Bool .
    eq validChar(S) = startsWithLetter(S) or (S == "_") or (ascii(S) >= ascii("0") and ascii(S) <= ascii("9")).
endfm


---(
    This module converts parsed structure of terms (from LANG-SYNTAX) into AST
)
fmod LANG is
    protecting META-LEVEL .
    protecting LANG-AST .
    protecting STRING .
    protecting IDENTIFIER .

    protecting LEXICAL .

    vars T T1 T2 : Term .
    vars Q Q1 Q2 : Qid .

    op process : Term ~> AST .

    ceq process('token[T]) = int(downTerm(getTerm(parsePredefined(T, 'INT, 'Int)), 0)) 
    if parsePredefined(T, 'INT, 'Int) :: ResultPair .

    ceq process('token[T]) = float(downTerm(getTerm(parsePredefined(T, 'FLOAT, 'Float)), 0.0)) 
    if parsePredefined(T, 'FLOAT, 'Float) :: ResultPair .

    ceq process('token[T]) = str(downTerm(getTerm(parsePredefined(T, 'STRING, 'String)), "")) 
    if parsePredefined(T, 'STRING, 'String) :: ResultPair .

    ceq process('token[T]) = id(string(downTerm(T, '$err))) 
    if valid(string(downTerm(T, '$err))) .

    eq process('_+_[T, T1]) = $add(process(T), process(T1)) .
    eq process('_-_[T, T1]) = $sub(process(T), process(T1)) .
    eq process('_*_[T, T1]) = $mult(process(T), process(T1)) .
    eq process('_/_[T, T1]) = $div(process(T), process(T1)) .
    eq process('_==_[T, T1]) = $eq(process(T), process(T1)) .
    eq process('_!=_[T, T1]) = $ne(process(T), process(T1)) .
    eq process('_>_[T, T1]) = $gt(process(T), process(T1)) .
    eq process('_>=_[T, T1]) = $ge(process(T), process(T1)) .
    eq process('_<_[T, T1]) = $lt(process(T), process(T1)) .
    eq process('_<=_[T, T1]) = $le(process(T), process(T1)) .
    eq process('_&&_[T, T1]) = $and(process(T), process(T1)) .
    eq process('_||_[T, T1]) = $or(process(T), process(T1)) .

    eq process('`(_`)[T]) = process(T) .
    eq process('_;[T]) = process(T) .

    eq process('_=_;[T, T1]) = assign(process(T), process(T1)) .
    eq process('pass`;.Stmt) = pass .
    eq process('return_;[T]) = return(process(T)) .

    eq process('__[T, T1]) = process(T) ; process(T1) .

    eq process('function_`(`)`{_`}[T, T1]) = function(extractId(process(T)), params(empty), process(T1)) .
    eq process('function_`(_`)`{_`}[T, T1, T2]) = function(extractId(process(T)), params(processParams(T1)), process(T2)) .
    eq process('_`(`)[T]) = call(extractId(process(T)), args(empty)) .
    eq process('_`(_`)[T, T1]) = call(extractId(process(T)), args(processArgs(T1))) .

    eq process('while_`{_`}[T, T1]) = $while(process(T), process(T1)) .
    eq process('if_`{_`}[T, T1]) = $ifelse(process(T), process(T1), pass) .
    eq process('if_`{_`}else`{_`}[T, T1, T2]) = $ifelse(process(T), process(T1), process(T2)) .

    op processArgs : Term ~> ArgListAST .
    eq processArgs(T) = process(T) [owise] .
    eq processArgs('_`,_[T, T1]) = processArgs(T) , processArgs(T1) .

    op processParams : Term ~> ParamListAST .
    eq processParams(T) = process(T) [owise] .
    eq processParams('_`,_[T, T1]) = processParams(T) , processParams(T1) .

    var STR : String .

    op extractId : AST ~> String .
    eq extractId(id(STR)) = STR . 

    op parsePredefined : Qid Qid Qid -> ResultPair? .
    eq parsePredefined(Q2, Q, Q1) = metaParse(upModule(Q, false), downTerm(Q2, 'error), Q1) .
endfm

load file.maude

view Oid from TRIV to CONFIGURATION is 
 sort Elt to Oid . 
endv
     
 
fmod MAYBE{X :: TRIV} is 
 sort Maybe{X} . 
 subsort X$Elt < Maybe{X} . 
 op maybe : -> Maybe{X} [ctor] . 
endfm

mod FILE-READER is
    protecting CONFIGURATION .
    protecting FILE .
    protecting MAYBE{Oid} .

    vars S TEXT : String .
    var FHIn : Oid .
    var Attrs : AttributeSet .

    
    op Reader : -> Cid [ctor] .
    op reader : -> Oid [ctor] .
    op result:_ : String -> Attribute [ctor] .
    op fhIn:_ : Maybe{Oid} -> Attribute [ctor] .
    op done:_ : Bool -> Attribute [ctor] .

    op getFileContents : String -> String .
    op extractReader : Configuration -> String .

    eq getFileContents(S) = extractReader(<> < reader : Reader | result: "", fhIn: maybe, done: false > openFile(fileManager, reader, S, "r")) .

    rl < reader : Reader | fhIn: maybe, Attrs > openedFile(reader, fileManager, FHIn)
    =>
        < reader : Reader | fhIn: FHIn, Attrs > getLine(FHIn, reader) .

    rl < reader : Reader | fhIn: FHIn, result: S, done: false, Attrs > gotLine(reader, FHIn, TEXT)
    =>
        if TEXT =/= "" then
            < reader : Reader | fhIn: FHIn, result: (S + TEXT), done: false, Attrs > getLine(FHIn, reader)
        else
            < reader : Reader | fhIn: maybe, result: S, done: true, Attrs >
            closeFile(FHIn, reader)
        fi
    .

    var CONF : Configuration .

    eq extractReader(< reader : Reader | result: S, done: true, Attrs > CONF)
        = S .
        
endm

fmod LANG-TEST-FUNCS is
    protecting LANG-SEMANTICS .


    op stdio : -> IO [ctor] .

    op funcs : -> FuncStorage .
    eq funcs = func("read", params(empty), $lock(id("res"), stdio) ; return(id("res")))
        ; func("write", params(id("s")), $dispatch(id("s"), stdio))
    .
endfm

---(
    Utility functions for easy execution
)
mod LANG-IO is
    protecting LANG .
    protecting LANG-SEMANTICS .
    protecting LANG-TEST-FUNCS .
    extending LEXICAL .
    protecting FILE-READER .

    vars S TEXT : String .
    var QID : Qid .
    var QIDS : QidList .
    var A : AST .

    op preParse : String -> ResultPair? .
    eq preParse(S) = metaParse(upModule('LANG-SYNTAX, false), tokenize(S), 'TopLevel) .

    op parse : String -> AST .
    eq parse(S) = process(getTerm(metaParse(upModule('LANG-SYNTAX, false), tokenize(S), 'TopLevel))) .

    op execute : String -> EvalResult .
    eq execute(S) = evalStmt(parse(S), [funcs | empty | stack(0, empty) ]) .

    op executeFile : String -> EvalResult .
    eq executeFile(S) = execute(getFileContents(S)) .
    
    var V : Value .
    op executeFile : String Value -> EvalResult .
    eq executeFile(S, V) = unlock(execute(getFileContents(S)), V) .

    op parseFile : String -> AST .
    eq parseFile(S) = parse(getFileContents(S)) .

    op executeAST : AST -> EvalResult .
    eq executeAST(A) = evalStmt(A, [funcs | empty | stack(0, empty) ]) .
endm

erew executeFile("test2.lang") .
erew executeFile("test2.lang", intVal(6)) .
